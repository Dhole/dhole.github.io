<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dhole&#39;s blog</title>
    <link>https://dhole.github.io/post/</link>
    <description>Recent content in Posts on Dhole&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Dec 2025 00:15:20 +0200</lastBuildDate>
    <atom:link href="https://dhole.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Collapse Ready Operating Systems - FreeBSD</title>
      <link>https://dhole.github.io/post/collapse_ready_os_freebsd/</link>
      <pubDate>Sun, 21 Dec 2025 00:15:20 +0200</pubDate>
      <guid>https://dhole.github.io/post/collapse_ready_os_freebsd/</guid>
      <description>&lt;p&gt;This post belongs to the Collapse Ready Operating System series.  See &lt;a href=&#34;https://dhole.github.io/post/collapse_ready_os&#34;&gt;this&#xA;post&lt;/a&gt; for an introduction.&lt;/p&gt;&#xA;&lt;h1 id=&#34;prelude&#34;&gt;Prelude&lt;/h1&gt;&#xA;&lt;p&gt;My last post in this series was more than two years ago.  When I started the&#xA;series I had an initial plan to test the three most well known BSD operating&#xA;systems, and after publishing articles for NetBSD and OpenBSD I soon&#xA;started doing my homework with FreeBSD; unfortunately I had a lot of hiccups.&#xA;I&amp;rsquo;ve made 4 different attempts at achieving the objectives in this series with&#xA;FreeBSD, the last one being last week, and none of them were fully successful.&#xA;The reason for trying several times instead of publishing the first result was&#xA;to see if some of the issues I encountered were temporary or bugs of a&#xA;particular release; but at the end I decided to publish the results I have.&lt;/p&gt;</description>
    </item>
    <item>
      <title>First impressions on Hare language</title>
      <link>https://dhole.github.io/post/hare_first_impressions/</link>
      <pubDate>Sat, 20 Jan 2024 14:45:38 +0100</pubDate>
      <guid>https://dhole.github.io/post/hare_first_impressions/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://harelang.org/&#34;&gt;Hare is a new programming language&lt;/a&gt; that was &lt;a href=&#34;https://harelang.org/blog/2022-04-25-announcing-hare/&#34;&gt;announced&#xA;in 2022&lt;/a&gt; and which was&#xA;started by &lt;a href=&#34;https://drewdevault.com/&#34;&gt;Drew DeValut&lt;/a&gt;.  It&amp;rsquo;s currently being&#xA;developed openly by a community of contributors.  Here&amp;rsquo;s a description of the&#xA;language from the official website:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Hare is a systems programming language designed to be simple, stable, and&#xA;robust. Hare uses a static type system, manual memory management, and a&#xA;minimal runtime. It is well-suited to writing operating systems, system&#xA;tools, compilers, networking software, and other low-level, high performance&#xA;tasks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Collapse Ready Operating Systems - NetBSD</title>
      <link>https://dhole.github.io/post/collapse_ready_os_netbsd/</link>
      <pubDate>Mon, 01 May 2023 12:00:20 +0200</pubDate>
      <guid>https://dhole.github.io/post/collapse_ready_os_netbsd/</guid>
      <description>&lt;p&gt;This is a blog post in the Collapse Ready Operating System series.  Read &lt;a href=&#34;https://dhole.github.io/post/collapse_ready_os&#34;&gt;this&#xA;post&lt;/a&gt; for an introduction.&lt;/p&gt;&#xA;&lt;h1 id=&#34;netbsd&#34;&gt;NetBSD&lt;/h1&gt;&#xA;&lt;p&gt;This time I have chosen &lt;a href=&#34;https://netbsd.org&#34;&gt;NetBSD&lt;/a&gt;.  I have used NetBSD previously in my Raspberry Pi (the first version).  I had a lot of fun building packages for ARM from the raspberry pi and trying them out (and finding bugs as well).  I remember fondly the regular &lt;a href=&#34;https://mail-index.netbsd.org/port-arm/2022/10/26/msg007897.html&#34;&gt;status reports&lt;/a&gt; made by Jun Ebihara along with raspberry pi images with many packages already installed.  I also remember building a raspberry pi image myself from a Linux host on amd64 using cross-compilation: I was quite impressed with how easy the process was.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Collapse Ready Operating Systems - OpenBSD</title>
      <link>https://dhole.github.io/post/collapse_ready_os_openbsd/</link>
      <pubDate>Tue, 21 Feb 2023 00:15:20 +0200</pubDate>
      <guid>https://dhole.github.io/post/collapse_ready_os_openbsd/</guid>
      <description>&lt;p&gt;This is a blog post in the Collapse Ready Operating System series.  Read &lt;a href=&#34;https://dhole.github.io/post/collapse_ready_os&#34;&gt;this&#xA;post&lt;/a&gt; for an introduction.&lt;/p&gt;&#xA;&lt;h1 id=&#34;openbsd&#34;&gt;OpenBSD&lt;/h1&gt;&#xA;&lt;p&gt;The OS analyzed in this post is &lt;a href=&#34;https://www.openbsd.org/&#34;&gt;OpenBSD&lt;/a&gt;.  I&amp;rsquo;ve&#xA;tried OpenBSD a few times in the past: once as a personal web server on an old&#xA;PC, and then as a desktop in a laptop as a secondary system.  That was a few&#xA;years ago.  My memories from it are that the system was very clean, everything&#xA;worked as expected, the performance was significantly slower than linux and&#xA;that I really appreciated all the care the developers put on the security side.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Collapse Ready Operating Systems - Intro</title>
      <link>https://dhole.github.io/post/collapse_ready_os/</link>
      <pubDate>Mon, 13 Feb 2023 12:23:20 +0200</pubDate>
      <guid>https://dhole.github.io/post/collapse_ready_os/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;Nowadays we live in a hyperconnected World that relies heavily on Internet&#xA;connection for day to day tasks in all levels.  I&amp;rsquo;m not very happy with this&#xA;relience of assuming Internet access 24h for everything, as I think it&#xA;disempowers the user.&lt;/p&gt;&#xA;&lt;p&gt;For example, whereas people before used to buy and own media, now they buy a&#xA;license to stream such media from the cloud.  This means that the user only has&#xA;access to the media as long as the platform exists, and we know that this is no&#xA;guarantee for the future.  It also means that the user can&amp;rsquo;t easily share the&#xA;media with their friends, that the consumption of the media can only be done in&#xA;authorized devices, etc.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CHIP-8 emulator in Rust: Embedded port.  Part 2</title>
      <link>https://dhole.github.io/post/chip8_emu_2/</link>
      <pubDate>Thu, 03 Jun 2021 10:23:20 +0200</pubDate>
      <guid>https://dhole.github.io/post/chip8_emu_2/</guid>
      <description>&lt;p&gt;This post is the continuation of &lt;a href=&#34;../chip8_emu_1/&#34;&gt;CHIP-8 emulator in Rust.  Part&#xA;1&lt;/a&gt;, please check it if you haven&amp;rsquo;t already!&lt;/p&gt;&#xA;&lt;p&gt;In this second part I will explain how I ported the CHIP-8 emulator I built in&#xA;Rust to an embedded ARM microcontroller.  I will explain the hardware I chose&#xA;to build this portable CHIP-8 device, the Rust libraries I used and I&amp;rsquo;ll give&#xA;an overview of how the code is laid out.  I excluded details about hardware&#xA;diagrams and explicit mention of how the hardware is connected to each pin&#xA;because I&amp;rsquo;m sure the astute reader will be able to figure this out from the&#xA;code itself.&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFS server over WireGuard in Alpine</title>
      <link>https://dhole.github.io/post/nfs_wireguard/</link>
      <pubDate>Fri, 21 May 2021 13:27:31 +0200</pubDate>
      <guid>https://dhole.github.io/post/nfs_wireguard/</guid>
      <description>&lt;p&gt;I have recently built a new storage server at home consisting of 6x2TB hard&#xA;drives configured as RAID-Z2 with ZFS.  For the operating system I have chosen&#xA;Alpine Linux, which is a distribution that I really like for its&#xA;lightweightness and its simplicity.&lt;/p&gt;&#xA;&lt;p&gt;Previously I had a storage server running Debian which I was sharing via sshfs.&#xA;sshfs is really easy to set up, as you just need to be running an ssh server,&#xA;nevertheless it has some disadvantages:&lt;/p&gt;</description>
    </item>
    <item>
      <title>CHIP-8 emulator in Rust.  Part 1</title>
      <link>https://dhole.github.io/post/chip8_emu_1/</link>
      <pubDate>Sun, 09 May 2021 17:23:20 +0200</pubDate>
      <guid>https://dhole.github.io/post/chip8_emu_1/</guid>
      <description>&lt;p&gt;I have been interested in the topic of emulation for many years; in particular,&#xA;game console emulation.  I started playing games under emulators when I was a&#xA;teenager and I was fascinated by how a piece of software would let me play a&#xA;game in a completely different architecture than the original one.&lt;/p&gt;&#xA;&lt;p&gt;I&amp;rsquo;ve you&amp;rsquo;ve ever been interested in learning about emulation, maybe you&amp;rsquo;ve&#xA;learned about the &lt;a href=&#34;https://en.wikipedia.org/wiki/CHIP-8&#34;&gt;CHIP-8&lt;/a&gt;; a&#xA;specification of a simple virtual machine designed to play 8bit 2D videogames&#xA;in the mid 1970s.  The connection between the CHIP-8 and emulation development&#xA;is that the specification of the CHIP-8 is very simple and makes the perfect&#xA;target for writing your first emulator.  In fact, that&amp;rsquo;s what I did in 2014: I&#xA;wrote &lt;a href=&#34;https://github.com/Dhole/Chip8-emu&#34;&gt;my first emulator&lt;/a&gt;, targeting the&#xA;CHIP-8 in C++.  Please, don&amp;rsquo;t take that C++ code too seriously!  I&amp;rsquo;ve never&#xA;been experienced in C++, and I wasn&amp;rsquo;t very experienced in software development&#xA;by then.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Thinkpad Helix 2 with Linux</title>
      <link>https://dhole.github.io/post/thinkpad_helix2_linux/</link>
      <pubDate>Tue, 03 Sep 2019 20:54:53 +0200</pubDate>
      <guid>https://dhole.github.io/post/thinkpad_helix2_linux/</guid>
      <description>&lt;h1 id=&#34;preface&#34;&gt;Preface&lt;/h1&gt;&#xA;&lt;p&gt;Recently I&amp;rsquo;ve bought a second hand Thinkpad Helix 2nd Gen with the intention of&#xA;using it mainly as a tablet to read PDF documents and comics (although I may&#xA;use it for Internet browsing and occasional development).  I like running free&#xA;software on my computers and so I decided to use GNU/Linux with this&#xA;tablet/laptop.  Here I will explain all the issues I encountered and how I&#xA;solved them.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pulseaudio for multi-user Linux</title>
      <link>https://dhole.github.io/post/pulseaudio_multiple_users/</link>
      <pubDate>Mon, 27 Aug 2018 20:54:53 +0200</pubDate>
      <guid>https://dhole.github.io/post/pulseaudio_multiple_users/</guid>
      <description>&lt;h1 id=&#34;my-setup&#34;&gt;My setup&lt;/h1&gt;&#xA;&lt;p&gt;For some time I&amp;rsquo;ve been using several unix users for my daily work in my&#xA;desktop computer.  After trying out Qubes OS for some time (an OS that achieves&#xA;security by compartmentalization: different kinds of activites are performed in&#xA;a different VM, isolating the data of each activity from each other), I came&#xA;back to GNU/Linux and realized that there&amp;rsquo;s already a security separation in&#xA;Unix (albeit not as secure as virtualization as in Qubes): users.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Programming Game Boy Chinese cartridges with an STM32F4</title>
      <link>https://dhole.github.io/post/gameboy_cartridge_rw_1/</link>
      <pubDate>Mon, 12 Mar 2018 00:33:57 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_cartridge_rw_1/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;For the past few years I have been interested in the Game Boy: I&amp;rsquo;ve written an &lt;a href=&#34;https://github.com/Dhole/miniBoy&#34;&gt;emulator in C (without sound)&lt;/a&gt;, I developed a &lt;a href=&#34;../../post/gameboy_cartridge_emu_1/&#34;&gt;physical cartridge &amp;ldquo;emulator&amp;rdquo; using a microcontroller&lt;/a&gt;, and most recently I&amp;rsquo;ve built a project to &lt;a href=&#34;../../post/gameboy_serial_1/&#34;&gt;interface my PC with the Game Link&lt;/a&gt;.  I&amp;rsquo;ve also played a bit with Game Boy programming.&lt;/p&gt;&#xA;&lt;p&gt;In the past I considered buying a Game Boy flashcart so that I could run demos and other scene ROMs on real hardware comfortably, but the price of such carts is a bit high.  After some reading on reddit, I learned that Chinese manufacturers are selling unlicensed Game Boy cartridges at very cheap prices ($5).  Not only that, but these cartridges use flash memory to store the ROM, and so have the potential to be reflashed!  I confirmed this fact after learning about a commercial device called the &lt;a href=&#34;https://bennvenn.myshopify.com/collections/frontpage/products/reader-writer-gen2&#34;&gt;jeoy-joebag, developed by BennVenn&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Printing on the Game Boy Printer using an STM32F4</title>
      <link>https://dhole.github.io/post/gameboy_serial_3/</link>
      <pubDate>Sun, 25 Feb 2018 16:33:57 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_serial_3/</guid>
      <description>&lt;p&gt;In this third and final part of the project about the Game Boy serial communication I will explain how I managed to print on the Game Boy Printer from my PC using an STM32F4 as the bridge between the two.  The encoding of the image into Game Boy tiles will happen on the PC, which will send it to the STM32F4 following the packet format of the Game Boy Printer.  The STM32F4 will only forward the data to the Game Boy Printer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Virtual Game Boy Printer with an STM32F4</title>
      <link>https://dhole.github.io/post/gameboy_serial_2/</link>
      <pubDate>Fri, 23 Feb 2018 16:33:57 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_serial_2/</guid>
      <description>&lt;p&gt;In this second part of the project about interfacing the Game Boy serial communication with an embedded development board I will explain how I built a Virtual Game Boy Printer.  The embedded board will be simulating a real Game Boy Printer, replying to the Game Boy following the protocol used by the Game Boy Printer so that the Game Boy sends the entire data meant to be print.  This data will then be forwarded to my computer which will construct a PNG image out of it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sniffing Game Boy serial traffic with an STM32F4</title>
      <link>https://dhole.github.io/post/gameboy_serial_1/</link>
      <pubDate>Wed, 14 Feb 2018 02:33:57 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_serial_1/</guid>
      <description>&lt;p&gt;In these series of blog posts I will write about the Game Boy serial communication protocol and how to interact with it by using an embedded development board.  The code for the development board will be written in C, and the code running on the computer will be written in &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The first part will consist on understanding the Game Boy serial communication protocol, becoming familiar with embedded development using the &lt;a href=&#34;https://github.com/libopencm3/libopencm3&#34;&gt;libopencm3&lt;/a&gt; free/libre library and finally building a serial communication sniffer to capture the transmission of data on the Game Link Cable.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Enabling LUKS on the PocketCHIP</title>
      <link>https://dhole.github.io/post/luks_on_chip/</link>
      <pubDate>Thu, 23 Nov 2017 14:35:56 -0800</pubDate>
      <guid>https://dhole.github.io/post/luks_on_chip/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;I&amp;rsquo;ve recently acquired a handheld ARM computer with screen and keyboard called&#xA;the &lt;a href=&#34;https://getchip.com/pages/pocketchip&#34;&gt;PocketCHIP&lt;/a&gt;.  The main board on the&#xA;device is called the &lt;a href=&#34;https://getchip.com/pages/chip&#34;&gt;CHIP&lt;/a&gt;, which is a tiny&#xA;ARM computer capable of running Linux that is sold for $9.&lt;/p&gt;&#xA;&lt;p&gt;After flashing it with the &lt;em&gt;CHIP 4.4 GUI&lt;/em&gt; OS, a flavor of Debian released by&#xA;Next Thing Co (the company that made the PocketCHIP)  I noticed I wasn&amp;rsquo;t able&#xA;to mount LUKS-encrypted partitions due to missing kernel modules.  In this post&#xA;I will explain what I had to do to build and install the missing modules&#xA;without the need to replace the entire kernel.  If you want to install a new&#xA;and different kernel you will need to follow a more involved process because&#xA;the WiFi and GPU drivers aren&amp;rsquo;t in the kernel sources and require you to build&#xA;them apart (and also fiddle with the device tree).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Alpine Linux: Upgrading on Raspberry Pi</title>
      <link>https://dhole.github.io/post/raspberry_pi_alpine_upgrade/</link>
      <pubDate>Mon, 26 Jun 2017 23:18:39 -0700</pubDate>
      <guid>https://dhole.github.io/post/raspberry_pi_alpine_upgrade/</guid>
      <description>&lt;p&gt;This post describes the upgrade procedure I follow to upgrade my Raspberry Pi&#xA;Alpine Linux installation.  Alpine Linux on the Raspberry Pi runs from ramfs&#xA;and thus the upgrading is not straightforward.  Most of the details are taken&#xA;from the &lt;a href=&#34;https://wiki.alpinelinux.org/wiki/Upgrading_Alpine#Upgrading_to_latest_release&#34;&gt;Alpine Linux&#xA;Wiki&lt;/a&gt;.&#xA;I&amp;rsquo;m not sure if Alpine Linux does any verification on the new downloaded&#xA;release, so I&amp;rsquo;m doing that manually on another computer.&lt;/p&gt;&#xA;&lt;h1 id=&#34;upgrading&#34;&gt;Upgrading&lt;/h1&gt;&#xA;&lt;p&gt;First of all, replace the repository confiration to point to the new version:&lt;/p&gt;</description>
    </item>
    <item>
      <title>rdiff-backup-1.2.8 in Alpine</title>
      <link>https://dhole.github.io/post/rdiff-backup-alpine/</link>
      <pubDate>Tue, 01 Nov 2016 01:17:17 -0700</pubDate>
      <guid>https://dhole.github.io/post/rdiff-backup-alpine/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;A few days ago I wanted to start doing incremental backups from my laptop to my&#xA;Raspberry Pi 2 running Alpine Linux.  I&amp;rsquo;ve had used rdiff-backup for some years&#xA;now and I&amp;rsquo;m really happy with it.  rdiff-backup is similar to rsync, in the&#xA;sense that lets you synchronize folders over the network, but it has two added&#xA;nice features: when synchronizing, only the differences between the files that&#xA;have changed are sent; and after every synchronization, the differences between&#xA;the old version of the files and the new ones is kept.  In other words, it keeps&#xA;backwards in time incremental backups, allowing you to revert the files in time.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raspberry Pi: git server (cgit with lighttpd)</title>
      <link>https://dhole.github.io/post/raspberry_pi_git/</link>
      <pubDate>Fri, 21 Oct 2016 15:14:27 -0700</pubDate>
      <guid>https://dhole.github.io/post/raspberry_pi_git/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;In this post I will explain what&amp;rsquo;s required to set up a git server.  We&amp;rsquo;ll use&#xA;&lt;a href=&#34;https://git.zx2c4.com/cgit/&#34;&gt;cgit&lt;/a&gt; to provide a web interface and also allow&#xA;cloning/pulling through HTTP.  ssh will also be available for cloning/pulling&#xA;and pushing.&lt;/p&gt;&#xA;&lt;p&gt;We&amp;rsquo;ll setup two groups of repositories: a public and a private one.&lt;/p&gt;&#xA;&lt;h1 id=&#34;cgit&#34;&gt;Cgit&lt;/h1&gt;&#xA;&lt;p&gt;First of all, we&amp;rsquo;ll create a &lt;em&gt;git&lt;/em&gt; user and move it&amp;rsquo;s home to the encrypted&#xA;partition.  For convenience we&amp;rsquo;ll also link that home directory to &lt;code&gt;/git&lt;/code&gt;.  This&#xA;will be useful to have nice paths for our repositories.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raspberry Pi: setting up alpine, lighttpd and letsencrypt</title>
      <link>https://dhole.github.io/post/raspberry_pi_alpine_lighttpd/</link>
      <pubDate>Fri, 21 Oct 2016 15:14:27 -0700</pubDate>
      <guid>https://dhole.github.io/post/raspberry_pi_alpine_lighttpd/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;In this post I will explain how to set up &lt;a href=&#34;https://alpinelinux.org/&#34;&gt;Alpine&#xA;Linux&lt;/a&gt; for the RPi, with the necessary configuration&#xA;for the RPi to power a USB hard drive, how to install lighttpd and configure&#xA;automatic renewal of TLS certificates with lestencrypt.&lt;/p&gt;&#xA;&lt;h1 id=&#34;alpine-linux&#34;&gt;Alpine Linux&lt;/h1&gt;&#xA;&lt;p&gt;Alpine Linux can be installed on te RPi following the &lt;a href=&#34;https://wiki.alpinelinux.org/wiki/Raspberry_Pi&#34;&gt;wiki&#xA;guide&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;After instalation, we add a new user which we will use for logging in:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adduser green&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;After logging in with our new user (using password) we&amp;rsquo;ll add some ssh public&#xA;keys for future logins:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raspberry Pi 2 I/O benchmarks</title>
      <link>https://dhole.github.io/post/raspberry_pi_benchmarks/</link>
      <pubDate>Thu, 20 Oct 2016 15:03:12 -0700</pubDate>
      <guid>https://dhole.github.io/post/raspberry_pi_benchmarks/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;I&amp;rsquo;m currently setting up a Raspberry Pi 2 as a home server for various services.&#xA;I&amp;rsquo;m gonna write a series of blog posts about how I configured my Raspberry Pi to&#xA;achieve my goals, which will be mainly setting up a git server and a backup&#xA;server.&lt;/p&gt;&#xA;&lt;h1 id=&#34;choice-of-distribution&#34;&gt;Choice of distribution&lt;/h1&gt;&#xA;&lt;p&gt;I discovered &lt;a href=&#34;https://alpinelinux.org/&#34;&gt;Alpine Linux&lt;/a&gt; while searching&#xA;lightweight distributions for the Raspberry Pi.  This is a lovely small Linux&#xA;distribution: one of the first things I noticed is how fast it runs on the RPi&#xA;due to using a ram filesystem by default; this is specially noticeable in the&#xA;RPi because usualy the operating system resides in the micro-SD card, which&#xA;usually offers really slow read and write operations.  Another really nice&#xA;feature is that it&amp;rsquo;s security-oriented, and as such the kernel is patched with&#xA;&lt;a href=&#34;https://www.grsecurity.net/&#34;&gt;grsecurity/PaX&lt;/a&gt; and the userland binaries (I&#xA;understand that means all packages- too) are compiled with hardening features:&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Position-independent_code&#34;&gt;Position Independent Executables&#xA;(PIE)&lt;/a&gt; and &lt;a href=&#34;http://wiki.osdev.org/Stack_Smashing_Protector&#34;&gt;stack&#xA;smashing protection&lt;/a&gt;.  This&#xA;distribution uses &lt;a href=&#34;https://www.musl-libc.org/&#34;&gt;musl libc&lt;/a&gt; instead of glib and&#xA;&lt;a href=&#34;https://busybox.net/&#34;&gt;busybox&lt;/a&gt; to provide all the basic utilities, decisions&#xA;that help making it small and lightweight.  I should also mention that OpenRC is&#xA;used for the init system (instead of following the current trend of switching to&#xA;systemd).&lt;/p&gt;</description>
    </item>
    <item>
      <title>No more unencrypted emails to gpg contacts</title>
      <link>https://dhole.github.io/post/check_mail_gpg/</link>
      <pubDate>Sat, 04 Jun 2016 00:13:28 +0200</pubDate>
      <guid>https://dhole.github.io/post/check_mail_gpg/</guid>
      <description>&lt;p&gt;I have been using mutt for about half a year already and I&amp;rsquo;m very happy with it.&#xA;The previous email client I used was Thunderbird (with the Enigmail extension to&#xA;handle GPG).  There were two main reasons that made me switch.&lt;/p&gt;&#xA;&lt;p&gt;The first one was that I often would like to check my email while I&amp;rsquo;m offline,&#xA;and it seems that Thunderbird is not very good at this.  Sometimes not all my&#xA;email would have been downloaded (just the headers), and I also found it&#xA;frustrating that after marking more than 50 emails as read while offline, they&#xA;would be marked as unread again once I went back online.  With mutt I&amp;rsquo;m using&#xA;mbsync (which apparently is faster than offlineimap) to sync my email to a local&#xA;folder with a cron job.  I couldn&amp;rsquo;t be happier.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reproducible builds on Debian for GSoC 2015, 1st update</title>
      <link>https://dhole.github.io/post/reproducible_builds_debian_gsoc2015_update_1/</link>
      <pubDate>Thu, 06 Aug 2015 20:12:15 +0200</pubDate>
      <guid>https://dhole.github.io/post/reproducible_builds_debian_gsoc2015_update_1/</guid>
      <description>&lt;p&gt;This is the second blog post I&amp;rsquo;m writing about my experiences contributing to Debian for Google Summer of Code 2015 (check my &lt;a href=&#34;https://dhole.github.io/post/reproducible_builds_debian_gsoc2015/&#34;&gt;first post&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;h1 id=&#34;status-update&#34;&gt;Status update&lt;/h1&gt;&#xA;&lt;h2 id=&#34;first-month&#34;&gt;First month&lt;/h2&gt;&#xA;&lt;p&gt;It&amp;rsquo;s been two months and a few days since the GSoC started. During the first month I worked on fixing specific packages, mainly concerning issues with timestamps, which is a very common source of unreproducibility. In many cases, during the build process files are compressed into gzip or zip archives, which store the creation time of files in the metadata. This can lead to unreproducible results when there is timezone variation between builds (easily fixed setting the timezone to UTC before the compression happens). In some cases the compressed files are generated during the build, and thus add build times in the metadata of compressed files (in this case the creation date of the files needs to be normalized somehow).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reproducible builds on Debian for GSoC 2015</title>
      <link>https://dhole.github.io/post/reproducible_builds_debian_gsoc2015/</link>
      <pubDate>Sun, 10 May 2015 17:14:05 +0200</pubDate>
      <guid>https://dhole.github.io/post/reproducible_builds_debian_gsoc2015/</guid>
      <description>&lt;p&gt;This is the first blog post of a series I will be writing about my experiences contributing to Debian for Google Summer of Code 2015.&lt;/p&gt;&#xA;&lt;h1 id=&#34;a-bit-about-myself&#34;&gt;A bit about myself&lt;/h1&gt;&#xA;&lt;p&gt;I&amp;rsquo;m a Spanish student doing a master&amp;rsquo;s in Computer Science in Barcelona. I graduated on Electrical Engineering (we call it Telecommunications here). I&amp;rsquo;ve always been interested in computing and programming and I have worked on several projects on my own using C, python and go. My main interests in the field are programming languages, security, cryptography, distributed and decentralized systems and embedded systems.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Full disk encryption on Samsung Chromebook with Arch Linux</title>
      <link>https://dhole.github.io/post/full_disk_encryption_samsung_chromebook/</link>
      <pubDate>Fri, 01 May 2015 23:58:40 +0200</pubDate>
      <guid>https://dhole.github.io/post/full_disk_encryption_samsung_chromebook/</guid>
      <description>&lt;p&gt;In this post I will explain the procedure I followed to have an Arch Linux&#xA;install on a Samsung Chromebook 1 (XE303C12-A01US) with full disk encryption&#xA;using kernel 3.8.&lt;/p&gt;&#xA;&lt;h1 id=&#34;kernel-compilation-and-preparing-sd-card&#34;&gt;Kernel compilation and preparing SD card&lt;/h1&gt;&#xA;&lt;h2 id=&#34;install-dependencies&#34;&gt;Install dependencies&lt;/h2&gt;&#xA;&lt;p&gt;Install the necessary depdendencies (In my case I was running ubuntu). Mainly&#xA;you need the tools for crosscompiling the kernel, configure u-boot and partition&#xA;the SD card with a GPT partition table.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt-get install u-boot-tools gcc-arm-linux-gnueabihf &lt;span style=&#34;color:#ae81ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    binutils-arm-linux-gnueabihf cgpt device-tree-compiler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;h2 id=&#34;set-up-some-directories-and-download-arch-and-kernel-sources&#34;&gt;Set up some directories and download arch and kernel sources&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TMP_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;pwd&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;/chromeos&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir -p $TMP_PATH&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd $TMP_PATH&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir -p root&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir -p mnt&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;Download my custom files&lt;/p&gt;</description>
    </item>
    <item>
      <title>Booting the GameBoy with a custom logo</title>
      <link>https://dhole.github.io/post/gameboy_custom_logo/</link>
      <pubDate>Thu, 25 Dec 2014 01:35:42 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_custom_logo/</guid>
      <description>&lt;p&gt;With the cartridge emulator implemented on an STM32F4 we can do some cool stuff.&#xA;For example, we can make the GameBoy boot with our own custom logo!&lt;/p&gt;&#xA;&lt;h1 id=&#34;bootstrap-rom&#34;&gt;Bootstrap ROM&lt;/h1&gt;&#xA;&lt;p&gt;When the GameBoy boots, an intenral Bootstrap ROM is mapped to the beginning of the&#xA;memory and execution begins. This bios is in charge of initializing the hardware&#xA;as well as scrolling the Nintendo logo and checking that the cartridge i valid.&#xA;The logo shown on screen is actually read from the cartridge; that&amp;rsquo;s the reason&#xA;why a black rectangle appears when no cartridge is inserted, or garbage appears&#xA;when the cartridge pins fail. If the Nintendo logo doesn&amp;rsquo;t match the copy stored&#xA;in the bios, the GameBoy locks itself. But there is a trick we can do! The&#xA;GameBoy reads the logo from the cartridge two times, the first one to draw it&#xA;on screen and the second one to check if it&amp;rsquo;s valid. We can thus send first a&#xA;custom logo and later the original one in order to let the GameBoy boot properly.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Emulating a GameBoy Cartridge with an STM32F4. Part 2</title>
      <link>https://dhole.github.io/post/gameboy_cartridge_emu_2/</link>
      <pubDate>Wed, 24 Dec 2014 19:46:07 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_cartridge_emu_2/</guid>
      <description>&lt;p&gt;This post is a continuation of &lt;a href=&#34;https://dhole.github.io/post/gameboy_cartridge_emu_1&#34;&gt;Emulating a GameBoy Cartridge with an STM32F4. Part 1&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;We have analyzed the memory bus of the GameBoy in order to obtain the timing&#xA;information of the different signals involved in the read and write operations&#xA;happening on the cartridge. We will now proceed to develop a system to emulate&#xA;the behaviour of the cartridge with the STM32F4.&lt;/p&gt;&#xA;&lt;h2 id=&#34;about-voltage-levels&#34;&gt;About voltage levels&lt;/h2&gt;&#xA;&lt;p&gt;As we noticed in the previous post, the GameBoy works at 5V whereas the STM32F4&#xA;works at 3.3V. We saw that most of the GPIOs of the STM32F4 are 5V tolerant, but&#xA;they still output 3.3V, so we need to make sure that the GameBoy will detect the&#xA;high levels properly. Luckily for us, the GameBoy works at TTL level:&#xA;&lt;a href=&#34;http://friedtj.free.fr/gb_eng.pdf&#34;&gt;source&lt;/a&gt;. This means that a 3.3V signal will&#xA;be read as a logic 1 by the GameBoy.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Emulating a GameBoy Cartridge with an STM32F4. Part 1</title>
      <link>https://dhole.github.io/post/gameboy_cartridge_emu_1/</link>
      <pubDate>Wed, 24 Dec 2014 03:33:57 +0100</pubDate>
      <guid>https://dhole.github.io/post/gameboy_cartridge_emu_1/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;The following project consists on emulating the functionality of a GameBoy&#xA;cartridge with the development board STM32F4. The system is fully functional&#xA;and is able to emulate real cartridges (as well as homebrew games) of the type&#xA;ROM Only and MBC1 (Memory Block Controller 1). In this post I will explain&#xA;how I managed to achieve this.&lt;/p&gt;&#xA;&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;&#xA;&lt;p&gt;Current flashcart systems commonly use a design consisting on a FPGA or CPLD&#xA;controlling the logic of the emulated cartridge (memory banking, RAM access,&#xA;etc.), a media storage (flash chip or SD card) and an SDRAM chip.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Welcome</title>
      <link>https://dhole.github.io/post/first/</link>
      <pubDate>Sat, 08 Nov 2014 17:04:11 +0100</pubDate>
      <guid>https://dhole.github.io/post/first/</guid>
      <description>&lt;p&gt;I had been planning on creating a blog to write about the stuff I do on my free time for a while.&#xA;In this blog I plan to write about the projects I develop as well as talking about interesting things&#xA;I lean about technology, hardware, security, embedded systems, programming languages and more.&lt;/p&gt;&#xA;&lt;p&gt;My first thought was to use a WordPress hosted at wordpress.com, but I didn&amp;rsquo;t want the adds. I searched&#xA;on the net for alternatives and found out about the static website generators, which allow you to host&#xA;the content in a static web server such as your github personal page. Right now this blog is posted in&#xA;my server, but I may move it to github if there is some traffic.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
