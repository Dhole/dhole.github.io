<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dhole&#39;s blog</title>
    <link>https://dhole.github.io/</link>
    <description>Recent content on Dhole&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 May 2015 17:14:05 +0200</lastBuildDate>
    <atom:link href="https://dhole.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Reproducible builds on Debian for GSoC 2015</title>
      <link>https://dhole.github.io/post/reproducible_builds_debian_gsoc2015/</link>
      <pubDate>Sun, 10 May 2015 17:14:05 +0200</pubDate>
      
      <guid>https://dhole.github.io/post/reproducible_builds_debian_gsoc2015/</guid>
      <description>

&lt;p&gt;This is the first blog post of a series I will be writing about my experiences contributing to Debian for Google Summer of Code 2015.&lt;/p&gt;

&lt;h1 id=&#34;a-bit-about-myself:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;A bit about myself&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m a Spanish student doing a master&amp;rsquo;s in Computer Science in Barcelona. I graduated on Electrical Engineering (we call it Telecommunications here). I&amp;rsquo;ve always been interested in computing and programming and I have worked on several projects on my own using C, python and go. My main interests in the field are programming languages, security, cryptography, distributed and decentralized systems and embedded systems.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m an advocate of free software, I try to use it as much as I&amp;rsquo;m able to in my devices and also try to convince my friends and family of its benefits. I have been using GNU/Linux for nearly ten years as my main operating system and I have tried several *BSD&amp;rsquo;s recently.&lt;/p&gt;

&lt;p&gt;One of my latest personal projects is a &lt;a href=&#34;https://github.com/Dhole/miniBoy&#34;&gt;gameboy emulator&lt;/a&gt; written in C (still work in progress) which already plays many games (without sound though) . You can find other minor projects in my &lt;a href=&#34;https://github.com/Dhole&#34;&gt;github page&lt;/a&gt; (I try to publish all the code I write online, under free software licence)&lt;/p&gt;

&lt;p&gt;After so many years of using free software and benefiting from it, I thought it was about time to contribute back! That&amp;rsquo;s why I gave GSoC a try and applied to work on the Reproducible Builds project for Debian :) And I got accepted!&lt;/p&gt;

&lt;h1 id=&#34;reproducible-builds:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;Reproducible Builds&lt;/h1&gt;

&lt;p&gt;The idea behind this project is that currently many packages aren&amp;rsquo;t built in a reproducible manner; that is, they contain timestamps, building machine name, unique IDs, and results from other processes that happen differently between machines, like file ordering in compressed files. The project aims to patch all the Debian packages / the building scripts in order to generate the same binary (bit by bit) independently of the machine, timezone, etc where it is built. This way, a cryptographic hash of the built package can be distributed and many people can rebuild the package to verify that the binary in the repositories indeed corresponds to the right source code by means of comparing the hash.&lt;/p&gt;

&lt;h2 id=&#34;motivation:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;One of the main advantages of the free software is that source code is available for peer review. This makes it easier for users to trust their software, as they can check the source to verify that the program is not doing anything bad. Even if the user doesn&amp;rsquo;t do that, they can trust the wider community with that task. But many distributions serve packages in binary form, so how do we know that the binary comes from the publicly available source code? The current solution is that the developers who build the packages sign them cryptographically; but this lands all the trust to the developer and the machines used for building.&lt;/p&gt;

&lt;p&gt;I became interested in this topic with a &lt;a href=&#34;https://www.youtube.com/watch?v=5pAen7beYNc&#34;&gt;very nice talk&lt;/a&gt; given at 31c3 by Mike Perry from Tor and Seth Schoen from the EFF. They focused on reproducible builds applied to the tor browser bundle, showing a small demo of how a building machine could be compromised to add hidden functionalities when compiling code (so that the developer could be signing a compromised package without their knowledge).&lt;/p&gt;

&lt;h2 id=&#34;benefits:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;Benefits&lt;/h2&gt;

&lt;p&gt;There are two main groups who benefit with reproducible builds:&lt;/p&gt;

&lt;h3 id=&#34;for-users:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;For users&lt;/h3&gt;

&lt;p&gt;The user can be more secure when installing packages in binary form since they don&amp;rsquo;t need to trust a specific developer or building machine. Even if they don&amp;rsquo;t rebuild the package by themselves to verify it, there would be others doing so, who will easily alert the community when the binary doesn&amp;rsquo;t match the source code.&lt;/p&gt;

&lt;h3 id=&#34;for-developers:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;For developers&lt;/h3&gt;

&lt;p&gt;The developer no longer has the responsibility of using his identity to sign the package for wide distribution, nor is that much responsible of the damage to users if their machine is compromised to alter the building process, since the community will easily detect it and alert them.&lt;/p&gt;

&lt;p&gt;This later point is specially useful with secure and privacy aware software. The reason is that there are many powerful organizations around the world with interest on having backdoors in widely used software, be it to spy on users or to target specific groups of people. Considering the amount of money these organizations have for such purposes, it&amp;rsquo;s not hard to imagine that they could try to blackmail developers into adding such backdoors on the built packages. Or they could try to compromise the building machine. With reproducible builds the developer is safer, as such attack is no longer useful.&lt;/p&gt;

&lt;h1 id=&#34;reproducible-builds-in-debian:17e5a0be75ac396c0c6958a6a4adaa17&#34;&gt;Reproducible Builds in Debian&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://wiki.debian.org/ReproducibleBuilds&#34;&gt;project&lt;/a&gt; kicked-off at Debian at mid 2013 , leaded by Lunar and soon followed by many other developers (h01ger, deki, mapreri, &amp;hellip;). Right now about 80% of the packages in the unstable branch of Debian can be built reproducibly. The project is very active, with many developers sending &lt;a href=&#34;https://bugs.debian.org/cgi-bin/pkgreport.cgi?usertag=reproducible-builds@lists.alioth.debian.org&#34;&gt;patches&lt;/a&gt; every week.&lt;/p&gt;

&lt;p&gt;A machine running &lt;a href=&#34;https://reproducible.debian.net/reproducible.html&#34;&gt;Jenkins&lt;/a&gt; (which was set up at the end of 2012 for other purposes) is being used since late 2014 to continuously build packages in different settings to check if they are built reproducibly or not.&lt;/p&gt;

&lt;p&gt;In order to analyze why packages fail to build reproducibly, a tool called &lt;strong&gt;debbindiff&lt;/strong&gt; has been developed, which is able to output in text or html form a smart diff of two builds.&lt;/p&gt;

&lt;p&gt;Another tool called &lt;strong&gt;strip-nondeterminism&lt;/strong&gt; has been developed to remove non-determinism from files during the building process.&lt;/p&gt;

&lt;p&gt;For this GSoC I plan on helping improving these tools (mainly debbindiff), write many patches to achieve reproducibility in more packages and write documentation about it. Some of the packages fail to build reproducibly due to specifics of their building processes, whereas others fail due to the usage of toolchains that add non-determinism. I&amp;rsquo;ll focus more on the later ones in order to improve the state more packages. akira will also be working on this project for this GSoC.&lt;/p&gt;

&lt;p&gt;Finally, I just want to add that I&amp;rsquo;m looking forward to contribute to Debian, meet the community and learn more about the internals of this awesome distribution!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Full disk encryption on Samsung Chromebook with Arch Linux</title>
      <link>https://dhole.github.io/post/full_disk_encryption_samsung_chromebook/</link>
      <pubDate>Fri, 01 May 2015 23:58:40 +0200</pubDate>
      
      <guid>https://dhole.github.io/post/full_disk_encryption_samsung_chromebook/</guid>
      <description>

&lt;p&gt;In this post I will explain the procedure I followed to have an Arch Linux
install on a Samsung Chromebook 1 (XE303C12-A01US) with full disk encryption
using kernel 3.8.&lt;/p&gt;

&lt;h1 id=&#34;kernel-compilation-and-preparing-sd-card:faa8511e92a2ce55340472c17643405e&#34;&gt;Kernel compilation and preparing SD card&lt;/h1&gt;

&lt;h2 id=&#34;install-dependencies:faa8511e92a2ce55340472c17643405e&#34;&gt;Install dependencies&lt;/h2&gt;

&lt;p&gt;Install the necessary depdendencies (In my case I was running ubuntu). Mainly
you need the tools for crosscompiling the kernel, configure u-boot and partition
the SD card with a GPT partition table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install u-boot-tools gcc-arm-linux-gnueabihf \
    binutils-arm-linux-gnueabihf cgpt device-tree-compiler
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;set-up-some-directories-and-download-arch-and-kernel-sources:faa8511e92a2ce55340472c17643405e&#34;&gt;Set up some directories and download arch and kernel sources&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;TMP_PATH=$(pwd)/chromeos
mkdir -p $TMP_PATH
cd $TMP_PATH
mkdir -p root
mkdir -p mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download my custom files&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/Dhole/alarm_install.git .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download Arch rootfs tarball&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://archlinuxarm.org/os/ArchLinuxARM-chromebook-latest.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download kernel 3.8 with ChromeOS patches&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KERNEL_BRANCH=&amp;quot;chromeos-3.8&amp;quot;
git clone https://chromium.googlesource.com/chromiumos/third_party/kernel.git \
    -b $KERNEL_BRANCH --depth 1 chromeos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-the-kernel:faa8511e92a2ce55340472c17643405e&#34;&gt;Build the kernel&lt;/h2&gt;

&lt;p&gt;Set up the config for the chromebook&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $KERNEL_BRANCH
CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm make mrproper
./chromeos/scripts/prepareconfig chromeos-exynos5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configure the kernel as needed (Alternativelly, download my custom .config). In
my case I enabled most of the cipher options to be able to use AES-XTS in LUKS.
Be sure to disable &amp;ldquo;Treat compiler warnings as errors&amp;rdquo; in menuconfig&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm make menuconfig
# or
cp ../files/.config .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile the kernel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm make uImage -j2
CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm make modules -j2
CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm make dtbs -j2

rm -rf ../lib/modules/
CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm INSTALL_MOD_PATH=$TMP_PATH \
    make modules_install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take the kernel.its from my files and make a u-boot image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# wget http://linux-exynos.org/dist/chromebook/snow/kernel.its \
#    -O arch/arm/boot/kernel.its
cp ../files/kernel.its arch/arm/boot/.
mkimage -f arch/arm/boot/kernel.its $TMP_PATH/vmlinux.uimg
cd $TMP_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;prepare-sd-card:faa8511e92a2ce55340472c17643405e&#34;&gt;Prepare SD card&lt;/h2&gt;

&lt;p&gt;Set your SD card device&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DISK=/dev/sde
sudo umount $DISK*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new disk label for GPT. Type y when prompted after running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo parted $DISK mklabel gpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Partition the SD card&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cgpt create -z $DISK 
sudo cgpt create $DISK 
sudo cgpt add -i 1 -t kernel -b 8192 -s 32768 -l U-Boot -S 1 -T 5 -P 10 $DISK 
sudo cgpt add -i 2 -t data -b 40960 -s 32768 -l Kernel $DISK
sudo cgpt add -i 12 -t data -b 73728 -s 32768 -l Script $DISK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create root partition&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PART_SIZE=$(cgpt show $DISK | egrep &#39;[0-9\ ]*Sec GPT table&#39; | awk &#39;{print $1}&#39;)
sudo cgpt add -i 3 -t data -b 106496 -s `expr $PART_SIZE - 106496` -l Root $DISK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tell the system to refresh what it knows about the disk partitions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;partprobe $DISK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Format partitions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkfs.ext2 &amp;quot;${DISK}2&amp;quot;
sudo mkfs.ext4 &amp;quot;${DISK}3&amp;quot;
sudo mkfs.vfat -F 16 &amp;quot;${DISK}12&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-nv-uboot-fb:faa8511e92a2ce55340472c17643405e&#34;&gt;Install nv_uboot_fb&lt;/h2&gt;

&lt;p&gt;Download and install the nv_uboot bootloader with framebuffer support in the SD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget -O - http://commondatastorage.googleapis.com/chromeos-localmirror/distfiles/nv_uboot-snow-simplefb.kpart.bz2 \
    | bunzip2 &amp;gt; nv_uboot.kpart
sudo dd if=nv_uboot.kpart of=&amp;quot;${DISK}1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;prepare-the-rootfs-for-encryption:faa8511e92a2ce55340472c17643405e&#34;&gt;Prepare the rootfs for encryption&lt;/h2&gt;

&lt;p&gt;Create key file. Store this file safely!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/urandom of=rootfs.key bs=128 count=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create luks container with key file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cryptsetup luksFormat &amp;quot;${DISK}3&amp;quot; rootfs.key -c aes-xts-plain64 -s 256 --hash sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add password to luks container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cryptsetup luksAddKey &amp;quot;${DISK}3&amp;quot; --key-file rootfs.key
sudo cryptsetup luksOpen &amp;quot;${DISK}3&amp;quot; alarm_rootfs -y --key-file rootfs.key
sudo mkfs.ext4 /dev/mapper/alarm_rootfs
sudo cryptsetup close alarm_rootfs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-arch-linux-kernel-and-custom-files:faa8511e92a2ce55340472c17643405e&#34;&gt;Install Arch Linux, kernel and custom files&lt;/h2&gt;

&lt;h3 id=&#34;mount-luks-and-boot-partition:faa8511e92a2ce55340472c17643405e&#34;&gt;Mount LUKS and boot partition&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo cryptsetup luksOpen &amp;quot;${DISK}3&amp;quot; alarm_rootfs -y --key-file rootfs.key
sudo mount /dev/mapper/alarm_rootfs root
sudo mount &amp;quot;${DISK}2&amp;quot; mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extract Arch Linux rootfs tarball&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -xf ArchLinuxARM-chromebook-latest.tar.gz -C root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the kernel to the kernel partition&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp vmlinux.uimg mnt
rm -rf root/usr/lib/modules/3.8.11/
cp -R lib root/usr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy custom mkinitcpio.conf (with crypt hook enabled)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp files/mkinitcpio.conf root/etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install initramfs from my files&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp files/uInitrd.img mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, if you already have an Arch installation on your Chromebook you
can create the initramfs yourself. From your Chromebook run as root.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pacman -S mkinitcpio uboot-mkimage
cp /root/files/mkinitcpio.conf /etc/mkinitcpio.conf
mkinitcpio -g ~/uInitrd.img
mount /dev/mmcblk1p2 /boot
mkimage -A arm -T ramdisk -C none -n initramfs -d ~/uInitrd.img /boot/uInitrd.uimg
umount /boot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install custom u-boot script to boot with kernel+initramfs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount &amp;quot;${DISK}12&amp;quot; mnt
mkdir -p mnt/u-boot
#wget http://archlinuxarm.org/os/exynos/boot.scr.uimg
mkimage -A arm -T script -C none -n &#39;Chromebook Boot Script&#39; \
    -d boot_custom2.scr boot.scr.uimg
cp boot.scr.uimg mnt/u-boot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;: Copy custom files for post-installation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp files/arch_mkinitcpio.sh root/root/
cp files/postinstall.sh root/root/   
cp files/arch/private/mlan0-wrt54gl root/etc/netctl/
mkdir -p root/root/files/
cp -R files/arch/* root/root/files/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;umount-luks-and-boot-partition:faa8511e92a2ce55340472c17643405e&#34;&gt;Umount LUKS and boot partition&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo umount mnt
sudo umount root
sudo cryptsetup close alarm_rootfs
sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;arch-configuration:faa8511e92a2ce55340472c17643405e&#34;&gt;Arch configuration&lt;/h1&gt;

&lt;p&gt;Boot your Chromebook and press Ctrl-U to boot from external drive. After you
see U-Boot start, press any kay to interrupt the boot process and type the
following in the prompt to reset the environment and save it to flash&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env default -f
saveenv
reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can now boot the Chromebook into Arch and configure the system. Login as
root to continue.&lt;/p&gt;

&lt;p&gt;Configure and connect wifi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wifi-menu mlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configure locale, timezone and hostname&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYHOSTNAME=&amp;quot;alarm&amp;quot;
USERNAME=&amp;quot;dhole&amp;quot;

locale-gen
localectl set-locale LANG=en_US.UTF-8
timedatectl set-timezone Europe/Madrid
hostnamectl set-hostname $MYHOSTNAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add user&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pacman -Sy
pacman -S sudo
useradd -m -G users -s /bin/bash $USERNAME
passwd $USERNAME
visudo # uncomment the wheel group
usermod -a -G wheel $USERNAME
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;post-install:faa8511e92a2ce55340472c17643405e&#34;&gt;Post install&lt;/h1&gt;

&lt;p&gt;At this point you should have a bootable full disk encryption Arch Install.
In the following lines I will detail the post installation steps I follow to
cover my needs in the laptop. Run all the following commands as root.&lt;/p&gt;

&lt;p&gt;Install some packages (tune this to your needs)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pacman -S mesa-libgl xorg-server xorg-xinit xorg-server-utils mesa xf86-video-fbdev \
xf86-input-synaptics unzip dbus lightdm lightdm-gtk-greeter gnome-icon-theme xfce4 \
firefox midori gnome-keyring wget vim ttf-dejavu ttf-ubuntu-font-family htop strace \
lsof i3 xscreensaver git conky dmenu profont dina-font tamsyn-font alsa-utils ntp \
pm-utils p7zip xarchiver unrar zip python-pip tmux mpv mc make tmux iputils rtorrent \
youtube-dl macchanger tree acpid pulseaudio pulseaudio-alsa mupdf clang file gvim \
mosh nmap rxvt-unicode thunar adduser rsyslog wicd chromium xf86-video-armsoc-chromium \
i3lock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Disable clearing of boot messages&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p /etc/systemd/system/getty@tty1.service.d/
echo -e &amp;quot;[Service]\nTTYVTDisallocate=no&amp;quot; &amp;gt; /etc/systemd/system/getty@tty1.service.d/noclear.conf
mkdir -p /etc/ld.conf/
echo &amp;quot;/usr/local/lib&amp;quot; &amp;gt;&amp;gt; /etc/ld.conf.d/local.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install fonts &lt;a href=&#34;http://linuxfonts.narod.ru/&#34;&gt;http://linuxfonts.narod.ru/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/fonts.conf /etc/fonts/conf.d/99-my-fonts.conf
cd /usr/share
7z e /root/files/fonts.7z
cd /root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enable suspend and xscreen lock on lid close:
&lt;a href=&#34;https://blog.omgmog.net/post/making-suspend-on-lid-close-work-with-arch-linux-on-the-hp-chromebook-11/&#34;&gt;https://blog.omgmog.net/post/making-suspend-on-lid-close-work-with-arch-linux-on-the-hp-chromebook-11/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/handler.sh /etc/acpi/handler.sh
systemctl enable acpid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install custom touchpad, keyboard, evdev&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/xorg.conf.d/* /etc/X11/xorg.conf.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enable lightdm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable lightdm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set default brightness on power up and script to change it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/brightness.conf /etc/tmpfiles.d/brightness.conf
cp /root/files/chbr /usr/local/bin/chbr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configure pulseaudio&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;load-module module-alsa-sink device=sysdefault&amp;quot; &amp;gt;&amp;gt; /etc/pulse/default.pa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enable rsyslog&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable rsyslog.service
systemctl start rsyslog.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change MAC at every connection&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/mac_change /etc/wicd/scripts/preconnect/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fix wicd-curses:
&lt;a href=&#34;https://github.com/voidlinux/void-packages/commit/220de599ad3ecba14423289209a3e4e031037edf&#34;&gt;https://github.com/voidlinux/void-packages/commit/220de599ad3ecba14423289209a3e4e031037edf&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/netentry_curses.py /usr/share/wicd/curses/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enable eduroam for wicd:
&lt;a href=&#34;http://chakraos.org/wiki/index.php?title=Wicd#Making_eduroam_work_with_wicd&#34;&gt;http://chakraos.org/wiki/index.php?title=Wicd#Making_eduroam_work_with_wicd&lt;/a&gt;
This setup is working for eduroam at Universitat Politècnica de Catalunya&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/ttls-80211 /etc/wicd/encryption/templates/
cd /etc/wicd/encryption/templates
echo ttls-80211 &amp;gt;&amp;gt; active
cd /root
mkdir -p /etc/ca-certificates/custom/
cp /root/files/AddTrustExternalCARoot.crt /etc/ca-certificates/custom/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chromium defaults&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/chromium_default /etc/chromium/default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install wicd saved networks (This is only for my personal usage, this config
is not in github)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /root/files/private/wireless-settings.conf /etc/wicd/
systemctl enable wicd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install my custom configuration for the user from my dot_files github repo. This
contains my vim settings, i3 window manager configuration for chromebook,
bashrc, tmux.conf, etc. Login as your user to run the following commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~
mkdir -p github
cd github
git clone https://github.com/Dhole/dot_files.git
cd dot_files
cp -R .* ~
cp ALARM/.* ~
sh vim_setup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;todo:faa8511e92a2ce55340472c17643405e&#34;&gt;TODO&lt;/h1&gt;

&lt;p&gt;There are only two things which I find missing from my installation.&lt;/p&gt;

&lt;p&gt;One is fixing an annoying issue with suspend: my chromebook wakes from sleep
after 10 minutes or so when the lid is closed. I&amp;rsquo;ve tryed using both suspend from
systemctl and from pm-suspend. I think this may be related to the kernel 3.8,
since I didn&amp;rsquo;t have this issue on 3.4 (well, not really, my laptop would wake
up some times, but it was not usual).&lt;/p&gt;

&lt;p&gt;The other one is doing the installation on the internal eMMC. Unfortunately the
SD card slot in the chromebook is placed very close to the end of the board, so
half of the SD card sticks out; it doesn&amp;rsquo;t look nice and I fear for the SD card
getting stuck somewhere when moving my chromebook around.&lt;/p&gt;

&lt;h1 id=&#34;resources:faa8511e92a2ce55340472c17643405e&#34;&gt;Resources&lt;/h1&gt;

&lt;p&gt;The installation process of Arch Linux on the Samsung Chromebook is taken from
[1], [2] and [3]. The procedure to compile and install of kernel 3.8 is taken from
[0]. The instructions to boot with initramfs to enable full disk encryotion
are taken from [4], and a reference for doing an install with full disk encryption
can be found at [5].&lt;/p&gt;

&lt;p&gt;[0] &lt;a href=&#34;https://elatov.github.io/2014/11/install-chromeos-kernel-38-on-samsung-chromebook/&#34;&gt;https://elatov.github.io/2014/11/install-chromeos-kernel-38-on-samsung-chromebook/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://elatov.github.io/2014/02/install-arch-linux-samsung-chromebook/&#34;&gt;https://elatov.github.io/2014/02/install-arch-linux-samsung-chromebook/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;http://archlinuxarm.org/platforms/armv7/samsung/samsung-chromebook&#34;&gt;http://archlinuxarm.org/platforms/armv7/samsung/samsung-chromebook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&#34;http://linux-exynos.org/wiki/Samsung_Chromebook_XE303C12/Installing_Linux&#34;&gt;http://linux-exynos.org/wiki/Samsung_Chromebook_XE303C12/Installing_Linux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] &lt;a href=&#34;http://archlinuxarm.org/forum/viewtopic.php?f=47&amp;amp;t=7071&#34;&gt;http://archlinuxarm.org/forum/viewtopic.php?f=47&amp;amp;t=7071&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] &lt;a href=&#34;https://dvikan.no/the-smallest-archlinux-install-guide&#34;&gt;https://dvikan.no/the-smallest-archlinux-install-guide&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Booting the GameBoy with a custom logo</title>
      <link>https://dhole.github.io/post/gameboy_custom_logo/</link>
      <pubDate>Thu, 25 Dec 2014 01:35:42 +0100</pubDate>
      
      <guid>https://dhole.github.io/post/gameboy_custom_logo/</guid>
      <description>

&lt;p&gt;With the cartridge emulator implemented on an STM32F4 we can do some cool stuff.
For example, we can make the GameBoy boot with our own custom logo!&lt;/p&gt;

&lt;h1 id=&#34;bootstrap-rom:ad55e3cbd1a3f7742559bc4fea68cdaf&#34;&gt;Bootstrap ROM&lt;/h1&gt;

&lt;p&gt;When the GameBoy boots, an intenral Bootstrap ROM is mapped to the beginning of the
memory and execution begins. This bios is in charge of initializing the hardware
as well as scrolling the Nintendo logo and checking that the cartridge i valid.
The logo shown on screen is actually read from the cartridge; that&amp;rsquo;s the reason
why a black rectangle appears when no cartridge is inserted, or garbage appears
when the cartridge pins fail. If the Nintendo logo doesn&amp;rsquo;t match the copy stored
in the bios, the GameBoy locks itself. But there is a trick we can do! The
GameBoy reads the logo from the cartridge two times, the first one to draw it
on screen and the second one to check if it&amp;rsquo;s valid. We can thus send first a
custom logo and later the original one in order to let the GameBoy boot properly.&lt;/p&gt;

&lt;p&gt;More on the GameBoy Bootstrap ROM can be read at &lt;a href=&#34;http://gbdev.gg8.se/wiki/articles/Gameboy_Bootstrap_ROM&#34;&gt;GBdevWiki&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;code:ad55e3cbd1a3f7742559bc4fea68cdaf&#34;&gt;Code&lt;/h1&gt;

&lt;p&gt;In order to achieve this we can modify the read function of our cartridge emulator
to the following:&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;no_show_logo&lt;/code&gt; flag is false at boot, and allows the first logo read (stored
in the ROM from 0x104 to 0x133) to be done on a custom array. Once the last byte
has been read, the flag is set to true so that the following reads are performed
to the real ROM.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://gist.github.com/Dhole/a097cee60b990f65d869.js&#34;&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;h2 id=&#34;custom-logo-creation:ad55e3cbd1a3f7742559bc4fea68cdaf&#34;&gt;Custom logo creation&lt;/h2&gt;

&lt;p&gt;In order to create custom logos I wrote two python scripts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/draw_logo.py&#34;&gt;draw_logo.py&lt;/a&gt;: Draws a logo on a window&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/make_logo.py&#34;&gt;make_logo.py&lt;/a&gt;: Converts a png logo image into a binary file to be used as a boot logo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The logo is stored in inside the cartridge with a binary representation:
Set bits represent a black pixel and unset bits represent a white pixel. The logo is
stored in blocks of 4x4, first filling the top part and later filling the bottom part.
The way the pixels are stored can be understood better by looking at &lt;code&gt;draw_logo.py&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make_logo.py&lt;/code&gt; allows you to convert a 48x8 pixel black and white png image to a
binary logo to be used by the cart emulator&lt;/p&gt;

&lt;h1 id=&#34;results:ad55e3cbd1a3f7742559bc4fea68cdaf&#34;&gt;Results&lt;/h1&gt;

&lt;p&gt;I have drawn the following logo to be used at boot:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/dhole_logo.png&#34; alt=&#34;Custom logo featuring my nickname and a cute Dhole&#34; /&gt;
    
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Custom logo featuring my nickname and a cute Dhole
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;In the following videos the GameBoy booting with the custom logo can be seen:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;https://www.youtube.com/embed/aVxJXK9QvPk&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Booting with the custom logo, running Dr Mario.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;https://www.youtube.com/embed/OPYkzv217P4&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Booting with the custom logo, running the demo Skinke by Jumalauta.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emulating a GameBoy Cartridge with an STM32F4. Part 2</title>
      <link>https://dhole.github.io/post/gameboy_cartridge_emu_2/</link>
      <pubDate>Wed, 24 Dec 2014 19:46:07 +0100</pubDate>
      
      <guid>https://dhole.github.io/post/gameboy_cartridge_emu_2/</guid>
      <description>

&lt;p&gt;This post is a continuation of &lt;a href=&#34;https://dhole.github.io/post/gameboy_cartridge_emu_1&#34;&gt;Emulating a GameBoy Cartridge with an STM32F4. Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We have analyzed the memory bus of the GameBoy in order to obtain the timing
information of the different signals involved in the read and write operations
happening on the cartridge. We will now proceed to develop a system to emulate
the behaviour of the cartridge with the STM32F4.&lt;/p&gt;

&lt;h2 id=&#34;about-voltage-levels:341ec718c3c25a798a6724c7a974b92c&#34;&gt;About voltage levels&lt;/h2&gt;

&lt;p&gt;As we noticed in the previous post, the GameBoy works at 5V whereas the STM32F4
works at 3.3V. We saw that most of the GPIOs of the STM32F4 are 5V tolerant, but
they still output 3.3V, so we need to make sure that the GameBoy will detect the
high levels properly. Luckily for us, the GameBoy works at TTL level:
&lt;a href=&#34;http://friedtj.free.fr/gb_eng.pdf&#34;&gt;source&lt;/a&gt;. This means that a 3.3V signal will
be read as a logic 1 by the GameBoy.&lt;/p&gt;

&lt;h1 id=&#34;setup:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Setup&lt;/h1&gt;

&lt;p&gt;We will use a similar setup here, although now we are going to connect all the
cartridge pins to the STM32F4 so that we can read/write the signals. We have
plenty of GPIOs on the STM32F4-Discovery, we just need to make sure we use the
5V compatible ones. I used the following setup:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CLK -&amp;gt; PC0&lt;/li&gt;
&lt;li&gt;RD -&amp;gt; PC1&lt;/li&gt;
&lt;li&gt;WR -&amp;gt; PC2&lt;/li&gt;
&lt;li&gt;DATA{0..7} -&amp;gt; PE{8..15}&lt;/li&gt;
&lt;li&gt;ADDR{0..15} -&amp;gt; PD{0..15}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure &gt;
    
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_setup.jpg&#34; alt=&#34;My setup with the GameBoy connected to the STM32F4-Discovery&#34; /&gt;
    
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        My setup with the GameBoy connected to the STM32F4-Discovery
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;h1 id=&#34;coding:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Coding&lt;/h1&gt;

&lt;p&gt;The code of this project can be found in my github page under an open source
license: &lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart&#34;&gt;github.com/Dhole&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;initialization:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Initialization&lt;/h2&gt;

&lt;p&gt;The initialization code can be found in &lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/main.c&#34;&gt;main.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first thing to do is to configure the GPIOs of the board. All the GPIOs are
configured as input, push pull mode (will be used when we set the DATA GPIO pins
to output) with pull down resistor (I believe pull down resistor is a good choice
to avoid current drain from the GameBoy(5V) to the STM32F4(3.3V)). The bus for
the GPIOs is configured at 100MHz (maximum frequency available).&lt;/p&gt;

&lt;p&gt;This functions can be found in &lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/main.c&#34;&gt;main.c&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void config_gpio_data();
void config_gpio_addr();
void config_gpio_sig();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Secondly, we will configure the CLK to act as a trigger on rise. To do this we
enable an interrupt for the GPIO we connected the CLK to that will execute a
handler for every level rise. In &lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/main.c&#34;&gt;main.c&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void config_PC0_int(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;read-write-handler:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Read/Write handler&lt;/h2&gt;

&lt;p&gt;The read/write handler can be found in &lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/stm32f4xx_it.c&#34;&gt;stm32f4xx_it.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The interrupt handler will be executed every time the CLK level goes high (rise).
It&amp;rsquo;s important to notice that there is some delay between the rise of CLK and
the execution of the handler. This may be because the GPIOs are peripherials that
communicate with the CPU through a bus clocked at 100MHz and also because the
interrupt is generated from a peripherial, and thus takes some time to be
processed by the CPU. This can be observed if you try to write a program that
toggles the output of a GPIO unpon rise of the CLK, and then monitor both signals
in an oscilloscope.&lt;/p&gt;

&lt;p&gt;The handler must wait some time until the addresses are ready in the bus. To
perform fine grained waits I use the NOP operation, which wastes one CPU cycle.
After reading the GPIOs connected to the addresses, we check if the operation is
a read or a write by reading the values of the GPIOs connected to RD and WR.&lt;/p&gt;

&lt;p&gt;In case of write, we must wait further until the data is available in the bus,
then we can read the GPIOs and perform the write.&lt;/p&gt;

&lt;p&gt;In case of the read, we must first set the GPIOs associated with the data as
output (we configured them to be input). Then we can output the data corresponding
to the address, and wait some cycles so that the GameBoy can read the contents.
After this, the GPIOs for data are configured back to input mode (default state).
Leaving the GPIOs of the data in input state as default is necessary because
sometimes the GameBoy will perfom write operations to internal RAM and having
these GPIOs as output will corrut the data sent by the GameBoy.&lt;/p&gt;

&lt;p&gt;If you take a look at IRQHandler examples for the STM32F4 you will notice some
differences. The library functions normally used in a handler have been replaced
by the specific operation. This is because calling a function consumes some
cycles (due to the context change) and also they contain asserts to verify the
input, which consumes more cycles. We are short in cycles here, so we try to avoid
all this.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://gist.github.com/Dhole/ed6cde3ec6b6574e080f.js&#34;&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;To perform an arbitrary number of NOP operations, I used a macro I found on
&lt;a href=&#34;https://stackoverflow.com/questions/8551418/c-preprocessor-macro-for-returning-a-string-repeated-a-certain-number-of-times&#34;&gt;stackoverflow&lt;/a&gt;. The C preprocessor doesn&amp;rsquo;t
allow to repeat an operations a number of times.&lt;/p&gt;

&lt;p&gt;Finding the proper number of NOP operations at each stage of the operation has
been the most difficult part of the implementation because it needs to be done
with trial and error. Adding a new case to an if statement changes the number of
cycles of the handler, so the number of NOPs may need to be readjusted. More over,
the compilation optimizations are quite unpredictable regarding how many op codes
are used for the code (and thus, how many cycles are spent on the execution), so
a small change can lead to a malfunctioning system.&lt;/p&gt;

&lt;h2 id=&#34;mbc1-implementation:341ec718c3c25a798a6724c7a974b92c&#34;&gt;MBC1 implementation&lt;/h2&gt;

&lt;p&gt;The read and write functions implementing the behaviour of the MBC1 can be found
in &lt;a href=&#34;https://github.com/Dhole/stm32f_GBCart/blob/master/stm32f4xx_it.c&#34;&gt;stm32f4xx_it.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A detailed explanation of the functionality of the different Memory Block
Controllers can be found in the &lt;a href=&#34;http://gbdev.gg8.se/wiki/articles/Memory_Bank_Controllers&#34;&gt;GBdevWiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For the read operation, three regions can be accessed. The first one maps to
the first 16KB of the ROM. The second one to the selectable ROM bank. The third
one to the selectable RAM bank, if any:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://gist.github.com/Dhole/dc998ea525a208987a69.js&#34;&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;For the write operation, it can happen that it accesses the RAM region, where
it performs a proper read, or it can access three other regions. The first one is
used to select the lower bits of the ROM bank. The second one is used to select the
RAM bank or the upper bits of the ROM bank, depending on the state of a ROM/RAM
mode flag. The third one is to enable or disable the ROM/RAM mode flag. There is also
an initial region to enable or disable the RAM, used by the cartridges to protect
the RAM agains data corruption, but it&amp;rsquo;s not needed here.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://gist.github.com/Dhole/7417a4095600fe31b1dd.js&#34;&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;h3 id=&#34;rom-and-ram:341ec718c3c25a798a6724c7a974b92c&#34;&gt;ROM and RAM&lt;/h3&gt;

&lt;p&gt;In order to allow the program to access to the contents of a ROM, I used the
unix &lt;code&gt;xxd&lt;/code&gt; tool to convert the binary file into a C header file containing an array
with the file contents:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp Tetris.gb rom.gb
xxd -i rom.gb | sed &#39;s/unsigned/unsigned const/g&#39; &amp;gt; tetris_rom.h
rm rom.gb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The contents of &lt;em&gt;tetris_rom.h&lt;/em&gt; will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned const char rom_gb[] = {
  0xc3, 0x0c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x0c, 0x02, 0xff,
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For games that use RAM, an array must be allocated on the SMT32F4. For this
purpose, an array of 32KB (Maximum RAM size for MBC1) will be declared:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uint8_t ram[0x8000]; // 32K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the saved game will only remain as long as the STM32F4 is not powered
off.&lt;/p&gt;

&lt;h1 id=&#34;results:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Results&lt;/h1&gt;

&lt;h2 id=&#34;photos:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Photos&lt;/h2&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_zelda.jpg&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_zelda.jpg&#34; alt=&#34;The Legend of Zelda. MBC1 game. Showing the cart RAM usage (The name, EDU, is saved in the cartridge RAM)&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        The Legend of Zelda. MBC1 game. Showing the cart RAM usage (The name, EDU, is saved in the cartridge RAM)
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_drmario.jpg&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_drmario.jpg&#34; alt=&#34;Dr. Mario. ROM Only game&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Dr. Mario. ROM Only game
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;h2 id=&#34;videos:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Videos&lt;/h2&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;https://www.youtube.com/embed/M7dIPUz1igs&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Running The Legend of Zelda, - Link&amp;rsquo;s Awakening, showing that the
cartridge RAM is working.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;https://www.youtube.com/embed/_hMnb0bsdyU&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Running the demo 20y by Snorpung.&lt;/p&gt;

&lt;h1 id=&#34;conclusions:341ec718c3c25a798a6724c7a974b92c&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;Being able to emulate a full cartridge with its RAM and memory banking with an
ARM development board was really awesome. I wasn&amp;rsquo;t sure this was doable, and
hadn&amp;rsquo;t seen anything similar. I don&amp;rsquo;t own any gameboy flashcarts, so being able
to run code on the gameboy from something I built was extremely satisfactory. I
enjoy watching works of demoscene, and with this project I was able to try out
many amazing demos on the GameBoy.&lt;/p&gt;

&lt;p&gt;On the technical side, this project took me a few days of fine tunning and
adding capabilites. This was my first time developing on the STM32F4 so I also
spent a few days documenting myself. The biggest issue I have found is the
timing constraints. Adding cases to if statements, changin the order of some
operations, modifying code&amp;hellip; all this modifies the timing of the instructions
generated by the compiler, sometimes not very intuitively due to strong compiler
optimizations. I spent some hours of trial and error checking that all the
operations worked fine. Also you may have noticed that all the code runs inside
the interruption handler. And this handler is triggered at 1MHz! This gives a
tight margin of operation. If the operations inside the interrupt takes too long,
they will mask the next interruption and a following read/write operation (in
case there was one) will be missed, probably crashing the GameBoy. Care must be
taken to not exceed this timing constraint.&lt;/p&gt;

&lt;p&gt;In the following post I will write about adding a custom boot logo to the
cartridge emulator. Stay tunned!&lt;/p&gt;

&lt;p&gt;Continuation: &lt;a href=&#34;https://dhole.github.io/post/gameboy_custom_logo&#34;&gt;Booting the GameBoy with a custom logo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emulating a GameBoy Cartridge with an STM32F4. Part 1</title>
      <link>https://dhole.github.io/post/gameboy_cartridge_emu_1/</link>
      <pubDate>Wed, 24 Dec 2014 03:33:57 +0100</pubDate>
      
      <guid>https://dhole.github.io/post/gameboy_cartridge_emu_1/</guid>
      <description>

&lt;h1 id=&#34;introduction:31aa9a0d0fadf1247fc28ab1f3666188&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;The following project consists on emulating the functionality of a GameBoy
cartridge with the development board STM32F4. The system is fully functional
and is able to emulate real cartridges (as well as homebrew games) of the type
ROM Only and MBC1 (Memory Block Controller 1). In this post I will explain
how I managed to achieve this.&lt;/p&gt;

&lt;h1 id=&#34;motivation:31aa9a0d0fadf1247fc28ab1f3666188&#34;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;Current flashcart systems commonly use a design consisting on a FPGA or CPLD
controlling the logic of the emulated cartridge (memory banking, RAM access,
etc.), a media storage (flash chip or SD card) and an SDRAM chip.&lt;/p&gt;

&lt;p&gt;The way this flashcarts work is that upon booting the console, they present a
small program that list the ROMs available in the media storage. The user selects
a game and the FPGA copies it from the media storage to the SDRAM to allow
fast access. Once the ROM has been copied, the FPGA acts as a gateway mapping
the contents of the SDRAM to the original cartridge mappings.&lt;/p&gt;

&lt;p&gt;Since the GameBoy cartridges use small ROM chips for which one can find
compatible FLASH chips in the market, it is a viable alternative to the FPGA
to take an original cartridge with a MBC5 and swap the original ROM chip with
a compatible FLASH memory. A cartridge with MBC5 is often selected because with
it, games with ROM Only and games using MBC1 can also be run (There is
compatibility). With this setup, the user is able to reprogram the FLASH many
times with different games and play them on the GameBoy.&lt;/p&gt;

&lt;p&gt;This procedure is detailed here:
&lt;a href=&#34;http://www.digital-circuitry.com/DOC/NINTENDO/GAMEBOY/DIY%20Nintendo%20GAMEBOY%20Classic%20Flash%20Cartridge.pdf&#34;&gt;DIY Nintendo GAMEBOY Classic Flash Cartridge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The FPGA system seems to allow much more freedom but it also involves more work:
the MBC5 (or the supported Memory Block Controllers) must be implemented in
hardware, an interface to access the media storage must be designed, the circuit
must be designed too with all the components (FPGA/CPLD, FLASH/SD Reader, SDRAM,
&amp;hellip;).&lt;/p&gt;

&lt;p&gt;An alternative to this one can think of would be to use a microcontroller
instead, interfacing the cartridge pins through the GPIO. This design can have
many complications since the timings to perform a read / write operation are
quite tight. The microcontroller should be fast enough to perform this operations
at the bus speed. When adding the functionality of the Memory Block controller
the timings could be hard to achieve.
&lt;a href=&#34;https://www.insidegadgets.com/2011/04/23/emulating-the-nintendo-logo-on-the-gameboy/&#34;&gt;Alex from Inside Gadgets&lt;/a&gt;
attempted to
achieve this using an Arduino. The low frequency of the Arduino made this project
infeasible, although Alex was able to achive the emulation of the Nintendo logo,
due to the fact that when the gameboy boots, the first read of the Nintendo logo
from the cartridge is timming predictable and not too fast:&lt;/p&gt;

&lt;p&gt;My aim was to try to implement a cartridge emulator using a faster microcontroller.&lt;/p&gt;

&lt;h1 id=&#34;the-hardware:31aa9a0d0fadf1247fc28ab1f3666188&#34;&gt;The hardware&lt;/h1&gt;

&lt;p&gt;For this project I choosed the STM32F4 Discovery. This development board features
an ARM Cortex-M4 which can run at 168MHz, with 1 MB Flash, 192 KB RAM and more than
70 GPIO. The GPIO are accessed through a peripherials bus that can run at 100MHz.
I also considered other boards such as the Teensy 3.1 but I ended up choosing
the STM32F4 because it had more Flash and RAM and because it was unexpensive (14€).&lt;/p&gt;

&lt;p&gt;On the other side, the GameBoy CPU runs at 4MHz. The comercial cartridges have
up to 512 KB of ROM and 128 KB of RAM, although the MBC5 is capable of handling
bigger ROMs. Many cartridges have a MBC (Memory Block Controler) such as the MBC5
or the MBC1. This controller allows the catridge to handle ROMs that don&amp;rsquo;t fit
into the GameBoy memory area reserved for the cartridge ROM by means of bank
selection. This selections are performed by writting into specific areas of the
memory map reserved for the ROM (So that the MBC can handle them).&lt;/p&gt;

&lt;p&gt;A list of characteristics of the comercial cartridges can be found here:
&lt;a href=&#34;http://www.devrs.com/gb/files/gbmbcsiz.txt&#34;&gt;GB Cart List&lt;/a&gt;
It is important to notice that the GameBoy works at 5V whereas the STM32F4 works
at 3.3V. Connecting 5V signals to the GPIOs of a 3.3 microcontroller can be
dangerous and damage the GPIO peripherials. Luckily the STM32F4-Discovery has
5V tolerance for most of the pins. To see which ones you can check the
documentation.&lt;/p&gt;

&lt;p&gt;With these characteristics it seems this project can be doable. If we consider
that the gameboy will perform at most a read / write per CPU cycle (We will later
see that this is not the case), we are left with 42 cycles of our dev board to handle
the operation. Taking into account that the GPIO bus is clocked at 100MHz, there
will be some delay which will leave us fewer cycles.&lt;/p&gt;

&lt;h1 id=&#34;analyzing-the-bus:31aa9a0d0fadf1247fc28ab1f3666188&#34;&gt;Analyzing the bus&lt;/h1&gt;

&lt;p&gt;In order to get an idea of how the bus used by the GameBoy to access the
cartridge works I decided to perform some captures using a Logic Analyzer. Since
I don&amp;rsquo;t have any hardware logic analyzer, I used a an awesome project
which consists of an implementation of a logic analyzer for the STM32F4, which
uses the SUMP protocol to interface with the PC (SUMP is a standard protocol for
hardware logic analyzers to interface with the client side). The logicdiscovery
allows to sample up to 20MHz on 16 channels, with up to 24k samples:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/logicdiscovery/&#34;&gt;logicdiscovery&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The client used is the Logic Sniffer, an open source Java client compatible with
the SUMP protocol:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lxtreme.nl/ols/&#34;&gt;Logic Sniffer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In order to analyze the bus while the GameBoy was performing reads and writes to
the cartridge, I soldered an FDD ribbon to the main board of the GameBoy,
intercepting the cartridge pins as follows:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_ribbon_1.jpg&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/gb_ribbon_1.jpg&#34; alt=&#34;Back of the GameBoy PCB with the cartridge pins soldered to a FDD ribbon.&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Back of the GameBoy PCB with the cartridge pins soldered to a FDD ribbon.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Since only 16 channels are available for the logicdiscovery I decided to monitor
the CLK, RD, WR, CS, DATA {0-4} and ADDR {0-8}. (That is, the lower 4 bits of
the data and the lower 8 bits of the address). With this we should be able to
get information about the timings of the different operations.&lt;/p&gt;

&lt;p&gt;The GameBoy cartridge pinout is well known, so it&amp;rsquo;s easy to figure out what every
pin on the PCB of the GameBoy does from a pinout picture:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
    
        &lt;img src=&#34;https://www.insidegadgets.com/wp-content/uploads/2011/03/IMG_1994.jpg&#34; alt=&#34;GameBoy cartridge pinout. Image from www.insidegadgets.com&#34; /&gt;
    
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        GameBoy cartridge pinout. Image from www.insidegadgets.com
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;h2 id=&#34;results:31aa9a0d0fadf1247fc28ab1f3666188&#34;&gt;Results&lt;/h2&gt;

&lt;p&gt;Upon analyzing the bus with the BATMAN game (ROM Only cartridge), the following is obtained:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_overview.png&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_overview.png&#34; alt=&#34;Logic capture overview&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Logic capture overview
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;The first thing I noticed is that the CLK is at 1MHz, this is good news for us:
we have more cycles for each operation. One oddity I found with the capture is
that we can see that the WR goes low a few times (WR is active on low). The
BATMAN cartridge doesn&amp;rsquo;t have RAM nor Memory Block Controller, so it doesn&amp;rsquo;t make
sense to write into it. Since we only have half of the adressess, we can&amp;rsquo;t say
for certain where the data is being written, but my guess is that we are seeing
writes being done to the internal GameBoy RAM.&lt;/p&gt;

&lt;p&gt;We can take a closer look to a read and a write and analyze what&amp;rsquo;s happening and
when. This information will give us an idea on when should we perform the reading
of the adresses for a write/read operation, and when to output the data on a
read operation.&lt;/p&gt;

&lt;p&gt;Notice that we have a 20MHz sampling rate, this means that a sample is being
taken every 50 ns, leading to an error of +/- 25 ns.&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_read_timings.png&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_read_timings.png&#34; alt=&#34;Read timings&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Read timings
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_write_timings.png&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_write_timings.png&#34; alt=&#34;Write timings&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Write timings
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;We can see that for a read operation, the GameBoy leaves WR and CS unactivate
(high) and the RD active (low). This is the default. The GameBoy sets the
address 150ns after the CLK rise, and the data is available in the bus
(coming from the cartridge) 200 ns later. We can&amp;rsquo;t say when the GameBoy reads
the data, but a guess would be around the CLK fall.&lt;/p&gt;

&lt;p&gt;For the write operation, the RD is set to unactive at the same time the address
and the data is set in the bus (150 ns after CLK rise). 100 ns later the CS is
activated. At the CLK fall, the WR is activated, allowing the cartridge to perform
the write for 300 ns. On the next cycle, we can see that RD and CS are reset to
the default state (low and high, active and unactive respectively). Notice that
the CS (Chip Select) is not strictly needed, although it seems to be used only
when accessing RAM (this is not clear).&lt;/p&gt;

&lt;p&gt;The writing timing analysis are sound with the analysis found in the unnoficial
&lt;a href=&#34;http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf&#34;&gt;GameBoy CPU Manual&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/cpu_manual_timing.png&#34;&gt;
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/cpu_manual_timing_small.png&#34; alt=&#34;RAM timings, taken from the Game Boy CPU Manual. Click for detailed timings.&#34; /&gt;
    &lt;/a&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        RAM timings, taken from the Game Boy CPU Manual. Click for detailed timings.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Now that we know that the information seen in the bus is not only the communication
between the GameBoy and the cartridge but all the read/write operations of the
GameBoy to its memory map, we can understand the following capture, which shows
a DMA operation (The GameBoy has a DMA functionality to allow to fast copy contents
from RAM or ROM to the OAM (Object Atribute Memory), used by the screen to draw
sprites):&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_DMA.png&#34;&gt;
    
        &lt;img src=&#34;https://dhole.github.io/media/gameboy_stm32f4/screen_dump_DMA.png&#34; alt=&#34;DMA in action&#34; /&gt;
    
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        DMA in action
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;In the following post I will write about the implementation of the cartridge
emulator. Stay tunned!&lt;/p&gt;

&lt;p&gt;Continuation: &lt;a href=&#34;https://dhole.github.io/post/gameboy_cartridge_emu_2&#34;&gt;Emulating a GameBoy Cartridge with an STM32F4. Part 2&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://dhole.github.io/post/first/</link>
      <pubDate>Sat, 08 Nov 2014 17:04:11 +0100</pubDate>
      
      <guid>https://dhole.github.io/post/first/</guid>
      <description>&lt;p&gt;I had been planning on creating a blog to write about the stuff I do on my free time for a while.
In this blog I plan to write about the projects I develop as well as talking about interesting things
I lean about technology, hardware, security, embedded systems, programming languages and more.&lt;/p&gt;

&lt;p&gt;My first thought was to use a WordPress hosted at wordpress.com, but I didn&amp;rsquo;t want the adds. I searched
on the net for alternatives and found out about the static website generators, which allow you to host
the content in a static web server such as your github personal page. Right now this blog is posted in
my server, but I may move it to github if there is some traffic.&lt;/p&gt;

&lt;p&gt;The platform choosen is &lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt;: a static website engine written in Go. There were
other options such as Jekyll and Oktopress, but I decided to try this one because I love Go and because
it&amp;rsquo;s really fast at generating the content.&lt;/p&gt;

&lt;p&gt;See you arround!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://dhole.github.io/about/</link>
      <pubDate>Fri, 07 Nov 2014 02:35:08 +0100</pubDate>
      
      <guid>https://dhole.github.io/about/</guid>
      <description>&lt;p&gt;
&lt;figure &gt;
    
    
        &lt;img src=&#34;https://avatars3.githubusercontent.com/u/1530972?v=3&amp;amp;s=256&#34;  /&gt;
    
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a Computer Science student from Barcelona with interests in embedded devices,
hardware hacking, security and cryptography among others.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been using Linux for nearly 10 years and tried some *BSD along the way. The
main programming languages I use are C, python and lately Go. I enjoy learning
about new programming languages and stuff in general.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;My github: &lt;a href=&#34;https://github.com/Dhole&#34;&gt;https://github.com/Dhole&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;My email: bankukur at gmail dot com&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;My email: dhole at openmailbox dot org&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Get my PGP public key at &lt;a href=&#34;https://dhole.github.io/dhole.asc&#34;&gt;dhole.asc&lt;/a&gt; or &lt;a href=&#34;http://pgp.mit.edu/pks/lookup?op=get&amp;amp;search=0x4FA457A18514CC63&#34;&gt;http://pgp.mit.edu/pks/lookup?op=get&amp;amp;search=0x4FA457A18514CC63&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PGP Fingerprint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pub   4096R/8514CC63 2015-01-25 [expires: 2020-01-24]
      Key fingerprint = 9BC4 8EF8 08DB 91DD 158D  559D 4FA4 57A1 8514 CC63
      uid                  Dhole &amp;lt;dhole@openmailbox.org&amp;gt;
      sub   4096R/C125274B 2015-01-25 [expires: 2020-01-24]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>