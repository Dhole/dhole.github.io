<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alpine on Dhole&#39;s blog</title>
    <link>https://lizard.kuasuka.com/blog/categories/alpine/</link>
    <description>Recent content in Alpine on Dhole&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Nov 2016 01:17:17 -0700</lastBuildDate>
    <atom:link href="https://lizard.kuasuka.com/blog/categories/alpine/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>rdiff-backup-1.2.8 in Alpine</title>
      <link>https://lizard.kuasuka.com/blog/post/rdiff-backup-alpine/</link>
      <pubDate>Tue, 01 Nov 2016 01:17:17 -0700</pubDate>
      
      <guid>https://lizard.kuasuka.com/blog/post/rdiff-backup-alpine/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;A few days ago I wanted to start doing incremental backups from my laptop to my
Raspberry Pi 2 running Alpine Linux.  I&amp;rsquo;ve had used rdiff-backup for some years
now and I&amp;rsquo;m really happy with it.  rdiff-backup is similar to rsync, in the
sense that lets you synchronize folders over the network, but it has two added
nice features: when synchronizing, only the differences between the files that
have changed are sent; and after every synchronization, the differences between
the old version of the files and the new ones is kept.  In other words, it keeps
backwards in time incremental backups, allowing you to revert the files in time.&lt;/p&gt;

&lt;p&gt;After trying to backup my Documents folder from my Debian laptop I encountered
an error that was caused by an incompatibility between versions.  &lt;a href=&#34;https://packages.debian.org/jessie/rdiff-backup&#34;&gt;Debian
packages version 1.2.8&lt;/a&gt; while
&lt;a href=&#34;https://pkgs.alpinelinux.org/packages?name=rdiff-backup&amp;amp;branch=&amp;amp;repo=&amp;amp;arch=&amp;amp;maintainer=&#34;&gt;Alpine packages version
1.3.3&lt;/a&gt;.
I found this to be an odd decision for Alpine.  &lt;a href=&#34;http://www.nongnu.org/rdiff-backup/&#34;&gt;Both versions were released in
March 2009&lt;/a&gt; and haven&amp;rsquo;t had any update
since then.  Version 1.2.8 is marked as stable whereas 1.3.3 is marked as
development/unstable.  I don&amp;rsquo;t know the internal differences between the two
versions, but I checked other distributions like
&lt;a href=&#34;https://www.archlinux.org/packages/?q=rdiff-backup&#34;&gt;Arch&lt;/a&gt; and they also package
version 1.2.8 instead of 1.3.3.&lt;/p&gt;

&lt;p&gt;So, in order to get the version 1.2.8 in Alpine I took the easy route and
installed it manually.  After having done this, I realize that maybe it would
have been much better to learn about the Alpine build system and build the
package by reverting the &lt;a href=&#34;http://git.alpinelinux.org/cgit/aports/commit/main/rdiff-backup/APKBUILD?id=b633874f5c8b490cbd371338f7fb7b8f649ca009&#34;&gt;commit that updated rdiff-backup from 1.2.8 to
1.3.3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;build-and-install&#34;&gt;Build and install&lt;/h1&gt;

&lt;p&gt;Anyhow, here&amp;rsquo;s how I installed rdiff-backup 1.2.8 manually:&lt;/p&gt;

&lt;p&gt;We first install rdiff-backup dependencies plus the packages required to build
rdiff-backup from source.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk add librsync
apk add gcc librsync-dev python-dev musl-dev patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We download the sources of rdiff-backup-1.2.8, check the hash sum to verify that
we got it right and we extract them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir tmp
cd tmp/
wget http://savannah.nongnu.org/download/rdiff-backup/rdiff-backup-1.2.8.tar.gz
[ &amp;quot;0d91a85b40949116fa8aaf15da165c34a2d15449b3cbe01c8026391310ac95db&amp;quot; \
    = $(sha256sum rdiff-backup-1.2.8.tar.gz | cut -d &amp;quot; &amp;quot; -f 1) ] &amp;amp;&amp;amp; echo OK
tar xzf rdiff-backup-1.2.8.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we download the required patch to build rdiff-backup with librsync-1.0.0,
in this case, from the Arch package git repository.  We check the patch and
apply it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://git.archlinux.org/svntogit/community.git/plain/trunk/rdiff-backup-1.2.8-librsync-1.0.0.patch?h=packages/rdiff-backup \
    -O rdiff-backup-1.2.8-librsync-1.0.0.patch
[ &amp;quot;a00d993d5ffea32d58a73078fa20c90c1c1c6daa0587690cec0e3da43877bf12&amp;quot; \
    = $(sha256sum rdiff-backup-1.2.8-librsync-1.0.0.patch | cut -d &amp;quot; &amp;quot; -f 1) ] &amp;amp;&amp;amp; echo OK
cd rdiff-backup-1.2.8/
patch -Np1 -i ../rdiff-backup-1.2.8-librsync-1.0.0.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are ready to build rdiff-backup and install it in the system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python setup.py build
python setup.py install --prefix=/usr --root=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We must not forget to add the newly installed files in the local backup
database, so that they are stored permanently.  I deliberately skip the docs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lbu add /usr/lib/python2.7/site-packages/rdiff_backup* /usr/bin/rdiff-backup*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we are done, we can remove the packages we used to build rdiff-backup.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk del gcc librsync-dev python-dev musl-dev patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now rdiff-backup works correctly from my Debian laptop to my Alpine Raspberry Pi
:)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi: git server (cgit with lighttpd)</title>
      <link>https://lizard.kuasuka.com/blog/post/raspberry_pi_git/</link>
      <pubDate>Fri, 21 Oct 2016 15:14:27 -0700</pubDate>
      
      <guid>https://lizard.kuasuka.com/blog/post/raspberry_pi_git/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In this post I will explain what&amp;rsquo;s required to set up a git server.  We&amp;rsquo;ll use
&lt;a href=&#34;https://git.zx2c4.com/cgit/&#34;&gt;cgit&lt;/a&gt; to provide a web interface and also allow
cloning/pulling through HTTP.  ssh will also be available for cloning/pulling
and pushing.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll setup two groups of repositories: a public and a private one.&lt;/p&gt;

&lt;h1 id=&#34;cgit&#34;&gt;Cgit&lt;/h1&gt;

&lt;p&gt;First of all, we&amp;rsquo;ll create a &lt;em&gt;git&lt;/em&gt; user and move it&amp;rsquo;s home to the encrypted
partition.  For convenience we&amp;rsquo;ll also link that home directory to &lt;code&gt;/git&lt;/code&gt;.  This
will be useful to have nice paths for our repositories.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adduser git
lbu add /home/git/

rmdir /home/git
ln -sf /mnt/disk/git /home/
cp -R /home/green/.ssh /home/git/.ssh
chown -R git:git /home/git/
ln -s /home/git/ /git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we install git, cgit and highlight (to provide code highlighting in
cgit).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk add highlight git cgit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cgit comes with a default script that will call highlight, but unfortunately
it&amp;rsquo;s expecting version 2 of highlight.  We&amp;rsquo;ll copy the script and change it to
use the argument format of version 3 of highlight (the line is already there, we
just comment the version 2 and uncomment the version 3).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/lib/cgit/filters/syntax-highlighting.sh /usr/lib/cgit/filters/syntax-highlighting3.sh
vim /usr/lib/cgit/filters/syntax-highlighting3.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;--- /usr/lib/cgit/filters/syntax-highlighting.sh
+++ /usr/lib/cgit/filters/syntax-highlighting3.sh
@@ -115,7 +115,7 @@
 # found (for example) on EPEL 6.
 #
 # This is for version 2
-exec highlight --force -f -I -X -S &amp;quot;$EXTENSION&amp;quot; 2&amp;gt;/dev/null
+#exec highlight --force -f -I -X -S &amp;quot;$EXTENSION&amp;quot; 2&amp;gt;/dev/null

 # This is for version 3
-#exec highlight --force -f -I -O xhtml -S &amp;quot;$EXTENSION&amp;quot; 2&amp;gt;/dev/null
+exec highlight --force -f -I -O xhtml -S &amp;quot;$EXTENSION&amp;quot; 2&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;lbu add /usr/lib/cgit/filters/syntax-highlighting3.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Highlight uses css to color the code, so we need to add some lines specifying
the colors we want to the css file cgit uses.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/share/webapps/cgit/cgit.css /usr/share/webapps/cgit/cgit-highlight.css
vim /usr/share/webapps/cgit/cgit-highlight.css
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;--- /usr/share/webapps/cgit/cgit.css
+++ /usr/share/webapps/cgit/cgit-highlight.css
@@ -809,3 +809,20 @@
 div#cgit table.ssdiff td.space div {
        min-height: 3em;
 }
+
+body.hl { background-color:#e0eaee; }
+pre.hl  { color:#000000; background-color:#e0eaee; font-size:10pt; font-family:&#39;Courier New&#39;,monospace;}
+.hl.num { color:#b07e00; }
+.hl.esc { color:#ff00ff; }
+.hl.str { color:#bf0303; }
+.hl.pps { color:#818100; }
+.hl.slc { color:#838183; font-style:italic; }
+.hl.com { color:#838183; font-style:italic; }
+.hl.ppc { color:#008200; }
+.hl.opt { color:#000000; }
+.hl.ipl { color:#0057ae; }
+.hl.lin { color:#555555; }
+.hl.kwa { color:#000000; font-weight:bold; }
+.hl.kwb { color:#0057ae; }
+.hl.kwc { color:#000000; font-weight:bold; }
+.hl.kwd { color:#010181; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;lbu add /usr/share/webapps/cgit/cgit-highlight.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned in the introduction, we will setup two folders, one for private repositories and the other one for public ones.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /mnt/disk
mkdir -p git/pub
mkdir -p git/priv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our setup we will use a general cgit configuration files, and two
specialized ones for the public and private folders.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /etc/cgit
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/cgit/cgitrc
css=/cgit/cgit-highlight.css
logo=/cgit/cgit.png
source-filter=/usr/lib/cgit/filters/syntax-highlighting3.sh
enable-git-config=1
enable-index-owner=0
enable-commit-graph=1
enable-index-links=1
enable-log-linecount=1
enable-log-filecount=1
#cache-size=512
robots=noindex, nofollow
root-title=Dhole&#39;s git repositories
root-desc=my personal repositories
remove-suffix=1
clone-prefix=https://lizard.kyasuka.com/cgit/cgit.cgi ssh://git@lizard.kyasuka.com:
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/cgit/cgitrc.public
include=/etc/cgit/cgitrc
clone-prefix=https://lizard.kyasuka.com/cgit/cgit.cgi ssh://git-kyasuka/git/pub
section=Public
scan-path=/mnt/distk/git/pub/
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/cgit/cgitrc.private
include=/etc/cgit/cgitrc
clone-prefix=https://lizard.kyasuka.com/private/cgit/cgit.cgi ssh://git-kyasuka/git/priv
section=Private
scan-path=/mnt/disk/git/priv/
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we create a new configuration file for lighttpd which will call
cgit via the cgi interface.  We are using the public and private configurations
by setting the &lt;code&gt;CGIT_CONFIG&lt;/code&gt; environment variable depending on the url path.
Remember to follow the previous post to add http auth to the urls that start
with &lt;code&gt;/private&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/lighttpd/cgit.conf
server.modules += (&amp;quot;mod_redirect&amp;quot;,
                   &amp;quot;mod_alias&amp;quot;,
                   &amp;quot;mod_cgi&amp;quot;,
                   &amp;quot;mod_fastcgi&amp;quot;,
                   &amp;quot;mod_rewrite&amp;quot;,
                   &amp;quot;mod_alias&amp;quot;,)

var.webapps = &amp;quot;/usr/share/webapps/&amp;quot;
$HTTP[&amp;quot;url&amp;quot;] =~ &amp;quot;^/cgit&amp;quot; {
        setenv.add-environment += ( &amp;quot;CGIT_CONFIG&amp;quot; =&amp;gt; &amp;quot;/etc/cgit/cgitrc.public&amp;quot; )
        server.document-root = webapps
        server.indexfiles = (&amp;quot;cgit.cgi&amp;quot;)
        cgi.assign = (&amp;quot;cgit.cgi&amp;quot; =&amp;gt; &amp;quot;&amp;quot;)
        mimetype.assign = ( &amp;quot;.css&amp;quot; =&amp;gt; &amp;quot;text/css&amp;quot; )
}
url.redirect = (
        &amp;quot;^/git/(.*)$&amp;quot; =&amp;gt; &amp;quot;/cgit/cgit.cgi/$1&amp;quot;,
)
$HTTP[&amp;quot;url&amp;quot;] =~ &amp;quot;^/private/cgit&amp;quot; {
        #url.rewrite-once = ( &amp;quot;^/private/cgit/(.*)&amp;quot; =&amp;gt; &amp;quot;/cgit/$1&amp;quot; )
        alias.url = ( &amp;quot;/private/&amp;quot; =&amp;gt; &amp;quot;/usr/share/webapps/&amp;quot; )
        setenv.add-environment += ( &amp;quot;CGIT_CONFIG&amp;quot; =&amp;gt; &amp;quot;/etc/cgit/cgitrc.private&amp;quot; )
        server.document-root = webapps
        server.indexfiles = (&amp;quot;cgit.cgi&amp;quot;)
        cgi.assign = (&amp;quot;cgit.cgi&amp;quot; =&amp;gt; &amp;quot;&amp;quot;)
        mimetype.assign = ( &amp;quot;.css&amp;quot; =&amp;gt; &amp;quot;text/css&amp;quot; )
}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/lighttpd/lighttpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
...
# {{{ includes
...
include &amp;quot;cgit.conf&amp;quot;
...
# }}}
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We commit every file to permanent storage and restart the lighttpd server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lbu commit
rc-service lighttpd start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should be able to visit the cgit interface from a browser now.&lt;/p&gt;

&lt;h1 id=&#34;git-usage&#34;&gt;Git usage&lt;/h1&gt;

&lt;p&gt;To automate making new repositories I wrote the following simple script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /home/git/new-repo.sh
#! /bin/sh

folder=$1
name=$2
desc=&amp;quot;$3&amp;quot;

if [ &amp;quot;$#&amp;quot; -ne 3 ]
then
        echo &amp;quot;Usage: $0 {pub|priv} name description&amp;quot;
        exit 1
fi

if [ ! -d &amp;quot;$folder&amp;quot; ]
then
        echo &amp;quot;Group $folder doesn&#39;t exist.  use pub/priv.&amp;quot;
        exit 2
fi

if [ -d &amp;quot;$folder/$name&amp;quot;.git ]
then
        echo &amp;quot;$folder/$name already exists&amp;quot;
        exit 3
fi

if [ &amp;quot;$desc&amp;quot; == &amp;quot;&amp;quot; ]
then
        echo &amp;quot;Please, provide a description in the 3rd argument.&amp;quot;
        exit 4
fi

cd &amp;quot;$folder&amp;quot;
mkdir &amp;quot;$name&amp;quot;.git
cd &amp;quot;$name&amp;quot;.git
git init --bare
echo &amp;quot;$desc&amp;quot; &amp;gt; description

echo &amp;quot;$folder/$name is ready.&amp;quot;
echo &amp;quot;&amp;quot;
echo &amp;quot;  Create a new repository&amp;quot;
echo &amp;quot;&amp;quot;
echo &amp;quot;git clone ssh://git-kyasuka/git/$folder/$name.git&amp;quot;
echo &amp;quot;cd $name&amp;quot;
echo &amp;quot;touch README.md&amp;quot;
echo &amp;quot;git add README.md&amp;quot;
echo &amp;quot;git commit -m \&amp;quot;add README\&amp;quot;&amp;quot;
echo &amp;quot;git push -u origin master&amp;quot;
echo &amp;quot;&amp;quot;
echo &amp;quot;  Existing folder or Git repository&amp;quot;
echo &amp;quot;&amp;quot;
echo &amp;quot;cd existing_folder&amp;quot;
echo &amp;quot;git init&amp;quot;
echo &amp;quot;git remote add origin ssh://git-kyasuka/git/$folder/$name.git&amp;quot;
echo &amp;quot;git add .&amp;quot;
echo &amp;quot;git commit&amp;quot;
echo &amp;quot;git push -u origin master&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, to create a new git repository I just do the following from my local
machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh git@lizard.kyasuka.com
./new-repo.sh pub test &amp;quot;This is a test repository&amp;quot;
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bonus&#34;&gt;Bonus&lt;/h1&gt;

&lt;p&gt;I had a few repositories in github, so I wrote the following python script to
clone them all into my server.  This will make the transition easier :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /mnt/disk/git/import-github.py
#! /usr/bin/env python3

from urllib.request import urlopen, urlretrieve
import os, sys, re, subprocess

user = sys.argv[1]
content = urlopen(&#39;https://api.github.com/users/%s/repos&#39; % user).read()
content = content.decode(&#39;UTF-8&#39;)


clone_urls = re.findall(&#39;(?&amp;lt;=&amp;quot;clone_url&amp;quot;:)&amp;quot;[^&amp;quot;]*&amp;quot;,&#39;, content)
descriptions = re.findall(&#39;(?&amp;lt;=&amp;quot;description&amp;quot;:)(null|&amp;quot;[^&amp;quot;]*&amp;quot;),&#39;, content)

descriptions = [d.replace(&#39;&amp;quot;&#39;, &#39;&#39;) for d in descriptions]
os.chdir(&#39;pub&#39;)
for i in range(0, len(clone_urls)):
    clone_url = clone_urls[i]
    clone_url = clone_url[1:-2]
    print(clone_url)
    subprocess.run([&#39;git&#39;, &#39;clone&#39;, &#39;--bare&#39;, clone_url])
    with open(clone_url.split(&#39;/&#39;)[-1] + &#39;/description&#39;, &#39;w&#39;) as desc_file:
        desc_file.write(descriptions[i] + &#39;\n&#39;)
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that concludes my initial series of posts on setting up my Raspberry Pi 2 to
act as a git server.  I&amp;rsquo;m planning on setting up a backup system in the future,
so I may write about it too :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi: setting up alpine, lighttpd and letsencrypt</title>
      <link>https://lizard.kuasuka.com/blog/post/raspberry_pi_alpine_lighttpd/</link>
      <pubDate>Fri, 21 Oct 2016 15:14:27 -0700</pubDate>
      
      <guid>https://lizard.kuasuka.com/blog/post/raspberry_pi_alpine_lighttpd/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In this post I will explain how to set up &lt;a href=&#34;https://alpinelinux.org/&#34;&gt;Alpine
Linux&lt;/a&gt; for the RPi, with the necessary configuration
for the RPi to power a USB hard drive, how to install lighttpd and configure
automatic renewal of TLS certificates with lestencrypt.&lt;/p&gt;

&lt;h1 id=&#34;alpine-linux&#34;&gt;Alpine Linux&lt;/h1&gt;

&lt;p&gt;Alpine Linux can be installed on te RPi following the &lt;a href=&#34;https://wiki.alpinelinux.org/wiki/Raspberry_Pi&#34;&gt;wiki
guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After instalation, we add a new user which we will use for logging in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adduser green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After logging in with our new user (using password) we&amp;rsquo;ll add some ssh public
keys for future logins:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /home/green/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will also download some configurations files for Vim and tmux:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl https://gitlab.com/dhole/dot_files/raw/master/.tmux.conf -o ~/.tmux.conf
curl https://gitlab.com/dhole/dot_files/raw/master/.airline_tmux -o ~/.airline_tmux
curl https://gitlab.com/dhole/dot_files/raw/master/.vimrc_basic -o ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we will log in as root and store the files persistently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lbu add /home/green/.ssh/authorized_keys
lbu add /home/green/.vimrc
lbu add /home/green/.tmux.conf
lbu add /home/green/.airline_tmux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From now on everything will be done as root.  For convenience I open a tmux
session after logging in as my regular user, and get a root shell in one tmux
window.&lt;/p&gt;

&lt;p&gt;First we will configure the boot process of the RPI to allow the USB connections
to offer the maximum power allowed, otherwise the external hard drive will not
work properly.  We are also assigning the minimum amount of RAM to the GPU
because we&amp;rsquo;ll be using the RPI as a headless server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# remount sd-card writeable
mount -o remount,rw /media/mmcblk0p1

# create rpi2/3 config
cat &amp;lt;&amp;lt; EOF &amp;gt; /media/mmcblk0p1/usercfg.txt
disable_splash=1
boot_delay=0
start_x=0
max_usb_current=1
gpu_mem=16
EOF

sync
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we install the required packages for our needs, and delete the default HTTP
server that comes with busybox.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk add vim sudo openssl bash lighttpd-mod_auth rsync
apk del mini_httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will use a script to decrypt the USB hard disk partition.  I will be running
this script manually every time I reboot the RPI.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /root/startup.sh
#! /bin/sh

cryptsetup luksOpen /dev/sda1 disk
mkdir -p /mnt/disk
mount /dev/mapper/disk /mnt/disk/

rc-service lighttpd start
EOF

lbu add /root/startup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lighttpd&#34;&gt;Lighttpd&lt;/h1&gt;

&lt;p&gt;We run the previous script to mount the encrypted partition in &lt;code&gt;/mnt/disk&lt;/code&gt; and
we&amp;rsquo;ll move some private folders there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/root/startup.sh
mkdir /mnt/disk/alpine-root
cd /mnt/disk/alpine-root
mkdir -p etc/dehydrated var/log/lighttpd var/www
ln -sf /mnt/disk/alpine-root/etc/dehydrated/ /etc/dehydrated
ln -sf /mnt/disk/alpine-root/var/www/ /var/www
ln -sf /mnt/disk/alpine-root/var/log/lighttpd /var/log/
chown -R lighttpd:lighttpd /var/log/lighttpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I want to enable HTTP auth for some paths in the HTTP server, so I&amp;rsquo;ll use a
script to add new triplets of user, realm and password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /etc/lighttpd/.htpasswd
cd /etc/lighttpd/.htpasswd/

cat &amp;lt;&amp;lt; EOF &amp;gt; hash.sh
#!/bin/sh
user=$1
realm=$2
pass=$3
hash=`echo -n &amp;quot;$user:$realm:$pass&amp;quot; | md5sum | cut -b -32`
echo &amp;quot;$user:$realm:$hash&amp;quot;
EOF

chmod 755 hash.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this I can add a username and password for the &amp;lsquo;private&amp;rsquo; realm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./hash.sh &#39;username&#39; &#39;private&#39; &#39;password&#39; &amp;gt; /etc/lighttpd/.htpasswd/lighttpd-htdigest.username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s time to configure lighttpd.  The file is already populated with the
default configuration, so I&amp;rsquo;m just showing the changes I added, copy them where
they belong as needed.  In the following configuration I&amp;rsquo;m configuring the
server to listen on port 80 to serve redirections to https; and I&amp;rsquo;m listening on
port 443 for the primary usage with sane security configurations.  I&amp;rsquo;ll be using
the certificate generated by the &lt;em&gt;dehydrated&lt;/em&gt; letsencrypt client, which will be
an elliptic curve key.  Finally I&amp;rsquo;m enabling http auth with the previous user
and password for all paths that start with &lt;code&gt;/private/&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/lighttpd/lighttpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;server.modules = (
...
    &amp;quot;mod_redirect&amp;quot;,
    &amp;quot;mod_access&amp;quot;,
    &amp;quot;mod_auth&amp;quot;,
    &amp;quot;mod_setenv&amp;quot;,
...
)
...
...
# {{{ includes
...
include &amp;quot;cgit.conf&amp;quot;
...
# }}}
...
...
$SERVER[&amp;quot;socket&amp;quot;] == &amp;quot;:443&amp;quot; {
  ssl.engine    = &amp;quot;enable&amp;quot;
  ssl.pemfile   = &amp;quot;/etc/dehydrated/certs/lizard.kyasuka.com/combined.pem&amp;quot;
  ssl.ca-file   = &amp;quot;/etc/dehydrated/certs/lizard.kyasuka.com/chain.pem&amp;quot;

  #### Mitigate BEAST attack:

  # A stricter base cipher suite. For details see:
  # http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-3389
  # or
  # http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3389

  ssl.cipher-list = &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES128+EECDH:AES128+EDH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK&amp;quot;
  #
  # Make the server prefer the order of the server side cipher suite instead of the client suite.
  # This is necessary to mitigate the BEAST attack (unless you disable all non RC4 algorithms).
  # This option is enabled by default, but only used if ssl.cipher-list is set.
  ssl.honor-cipher-order = &amp;quot;enable&amp;quot;

  # Mitigate CVE-2009-3555 by disabling client triggered renegotiation
  # This option is enabled by default.
  #
  ssl.disable-client-renegotiation = &amp;quot;enable&amp;quot;
  #

  ssl.use-compression = &amp;quot;disable&amp;quot;
  ssl.use-sslv2 = &amp;quot;disable&amp;quot;
  ssl.use-sslv3 = &amp;quot;disable&amp;quot;

  ssl.dh-file = &amp;quot;/etc/ssl/dhparam.pem&amp;quot;
  ssl.ec-curve = &amp;quot;prime256v1&amp;quot;

  setenv.add-response-header = ( &amp;quot;Strict-Transport-Security&amp;quot; =&amp;gt; &amp;quot;max-age=15768000&amp;quot;) # six months
}
...
...
$HTTP[&amp;quot;url&amp;quot;] =~ &amp;quot;^/private/(.*)&amp;quot; {
  auth.backend = &amp;quot;htdigest&amp;quot;
  auth.backend.htdigest.userfile = &amp;quot;/etc/lighttpd/.htpasswd/lighttpd-htdigest.green&amp;quot;
  auth.require = ( &amp;quot;&amp;quot; =&amp;gt;
      (
      &amp;quot;method&amp;quot;  =&amp;gt; &amp;quot;digest&amp;quot;,
      &amp;quot;realm&amp;quot;   =&amp;gt; &amp;quot;private&amp;quot;,
      &amp;quot;require&amp;quot; =&amp;gt; &amp;quot;valid-user&amp;quot;
      ),
  )
}
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to protect against the &lt;a href=&#34;https://weakdh.org/&#34;&gt;Logjam Attack&lt;/a&gt; we&amp;rsquo;ll
generate a new Diffie-Hellman group of 4096 bits.  I first tried this on the RPi
but after 12h it hadn&amp;rsquo;t finished, so I did it on my laptop and transfered the
file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl dhparam -out /etc/ssl/dhparam.pem 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;letsencrypt&#34;&gt;Letsencrypt&lt;/h1&gt;

&lt;p&gt;Now we install the &lt;a href=&#34;https://github.com/lukas2511/dehydrated/&#34;&gt;dehydrated letsencrypt
client&lt;/a&gt;.  I&amp;rsquo;m choosing this one
instead of the official one to avoid pulling all the python dependencies, and to
avoid running it as root.  dehydrated is written entirely in bash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /mnt/disk/alpine-root/git
cd /mnt/disk/alpine-root/git/
git clone https://github.com/lukas2511/dehydrated

mkdir /etc/dehydrated
cp /mnt/disk/alpine-root/git/dehydrated/docs/examples/config /etc/dehydrated/config
mkdir -p /var/www/localhost/htdocs/.well-known/acme-challenge

chown lighttpd:lighttpd -R /var/www

lbu inc /var/www
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we edit the default dehydrated config to use a different path to store the
challenge and to generate elliptic curve keys, using the &lt;a href=&#34;https://www.prime256v1.com&#34;&gt;NIST P-256
curve&lt;/a&gt;.  I would have preferred using the &lt;a href=&#34;https://ed25519.cr.yp.to/&#34;&gt;Ed25519
curve&lt;/a&gt;, but it&amp;rsquo;s not yet part of the TLS standard :(&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/dehydrated/config
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
WELLKNOWN=&amp;quot;/var/www/localhost/htdocs/.well-known/acme-challenge/&amp;quot;
...
KEY_ALGO=prime256v1
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we add the list of domains and subdomains that we want plan to use.  Every
line should be a space separated list of subdomains belonging to the same
domain.  I&amp;rsquo;m only using one subdomain for one domain.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/dehydrated/domains.txt
lizard.kyasuka.com
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we run the letsencrypt client to generate and sign the certificates, and
generate a file with the private key and certificate that lighttpd will use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chown lighttpd:lighttpd -R /etc/dehydrated/

sudo -u lighttpd /mnt/disk/alpine-root/git/dehydrated/dehydrated -c

sudo -u lighttpd cat /etc/dehydrated/certs/lizard.kyasuka.com/privkey.pem \
/etc/dehydrated/certs/lizard.kyasuka.com/cert.pem \
&amp;gt; /etc/dehydrated/certs/lizard.kyasuka.com/combined.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To automate the renewal process we&amp;rsquo;ll add an entry to the lighttpd user crontab.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -u lighttpd crontab -e
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;42      5       *       *       *       /mnt/disk/alpine-root/git/dehydrated/dehydrated -c &amp;amp;&amp;amp; \
                                        cat /etc/dehydrated/certs/lizard.kyasuka.com/privkey.pem \
                                        /etc/dehydrated/certs/lizard.kyasuka.com/cert.pem \
                                        &amp;gt; /etc/dehydrated/certs/lizard.kyasuka.com/combined.pem &amp;amp;&amp;amp; \
                                        /mnt/disk/alpine-root/git/dehydrated/dehydrated -gc
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;last-details&#34;&gt;Last details&lt;/h1&gt;

&lt;p&gt;Finally, considering that Apline Linux runs from RAM we realize that if the RPi
powers off, we&amp;rsquo;ll lose al logs (except for lighttpd&amp;rsquo;s logs, which we are writing
directly to our encrypted partition).  It&amp;rsquo;s useful to read the logs after our
server goes down, so we add a crontab that will rsync the logs to the encrypted
parititon.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
...
*/15    *       *       *       *       ls /mnt/disk/alpine-root &amp;amp;&amp;amp; \
                                        rsync -a /var/log/dmesg /var/log/messages /mnt/disk/alpine-root/var/log/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, commit all the changes to store them permanently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lbu commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the next post I will explain how to use the RPi as a git server, with cgit a
the web interface.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi 2 I/O benchmarks</title>
      <link>https://lizard.kuasuka.com/blog/post/raspberry_pi_benchmarks/</link>
      <pubDate>Thu, 20 Oct 2016 15:03:12 -0700</pubDate>
      
      <guid>https://lizard.kuasuka.com/blog/post/raspberry_pi_benchmarks/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m currently setting up a Raspberry Pi 2 as a home server for various services.
I&amp;rsquo;m gonna write a series of blog posts about how I configured my Raspberry Pi to
achieve my goals, which will be mainly setting up a git server and a backup
server.&lt;/p&gt;

&lt;h1 id=&#34;choice-of-distribution&#34;&gt;Choice of distribution&lt;/h1&gt;

&lt;p&gt;I discovered &lt;a href=&#34;https://alpinelinux.org/&#34;&gt;Alpine Linux&lt;/a&gt; while searching
lightweight distributions for the Raspberry Pi.  This is a lovely small Linux
distribution: one of the first things I noticed is how fast it runs on the RPi
due to using a ram filesystem by default; this is specially noticeable in the
RPi because usualy the operating system resides in the micro-SD card, which
usually offers really slow read and write operations.  Another really nice
feature is that it&amp;rsquo;s security-oriented, and as such the kernel is patched with
&lt;a href=&#34;https://www.grsecurity.net/&#34;&gt;grsecurity/PaX&lt;/a&gt; and the userland binaries (I
understand that means all packages- too) are compiled with hardening features:
&lt;a href=&#34;https://en.wikipedia.org/wiki/Position-independent_code&#34;&gt;Position Independent Executables
(PIE)&lt;/a&gt; and &lt;a href=&#34;http://wiki.osdev.org/Stack_Smashing_Protector&#34;&gt;stack
smashing protection&lt;/a&gt;.  This
distribution uses &lt;a href=&#34;https://www.musl-libc.org/&#34;&gt;musl libc&lt;/a&gt; instead of glib and
&lt;a href=&#34;https://busybox.net/&#34;&gt;busybox&lt;/a&gt; to provide all the basic utilities, decisions
that help making it small and lightweight.  I should also mention that OpenRC is
used for the init system (instead of following the current trend of switching to
systemd).&lt;/p&gt;

&lt;h1 id=&#34;personal-requirements&#34;&gt;Personal requirements&lt;/h1&gt;

&lt;p&gt;Now that I have choosen a distribution, I have a requierement for my setup: all
the personal data I store in the RPi (git repositories, backups, websites) must
be encrypted in the disk.&lt;/p&gt;

&lt;h1 id=&#34;benchmarks&#34;&gt;Benchmarks&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m mainly interested in how fast files can be written on the encrypted
partition.  This files will probably be comming from the network.&lt;/p&gt;

&lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;

&lt;p&gt;To achieve better I/O and to avoid damaging the micro-SD (or a USB stick) I&amp;rsquo;m
gonna use an external USB hard disk (western digital My Passport) for storage.&lt;/p&gt;

&lt;p&gt;The RPi will be connected to a 1 Gbps switch (which shouldn&amp;rsquo;t matter considering
that the Ethernet interface of all the RPis are &lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;100&lt;/sub&gt; Mbps).&lt;/p&gt;

&lt;h2 id=&#34;cryptsetup&#34;&gt;cryptsetup&lt;/h2&gt;

&lt;p&gt;This test will give us the encryption/decryption speeds running from memory, so
they represent an upper bound on the write speed that we can achieve in disk.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lizard:~/git/public/test.git$ cryptsetup benchmark
# Tests are approximate using memory only (no storage IO).
PBKDF2-sha1        42555 iterations per second for 256-bit key
PBKDF2-sha256      73635 iterations per second for 256-bit key
PBKDF2-sha512      33781 iterations per second for 256-bit key
PBKDF2-ripemd160   36408 iterations per second for 256-bit key
PBKDF2-whirlpool   11497 iterations per second for 256-bit key
#  Algorithm | Key |  Encryption |  Decryption
     aes-cbc   128b    12.6 MiB/s    14.8 MiB/s
 serpent-cbc   128b           N/A           N/A
 twofish-cbc   128b           N/A           N/A
     aes-cbc   256b    10.9 MiB/s    11.2 MiB/s
 serpent-cbc   256b           N/A           N/A
 twofish-cbc   256b           N/A           N/A
     aes-xts   256b    14.6 MiB/s    14.4 MiB/s
 serpent-xts   256b           N/A           N/A
 twofish-xts   256b           N/A           N/A
     aes-xts   512b    11.2 MiB/s    11.0 MiB/s
 serpent-xts   512b           N/A           N/A
 twofish-xts   512b           N/A           N/A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My encrypted partition is using AES-XTS (this mode is the current
recommendation) with 256 bit keys, so we achieve &lt;strong&gt;14.6 MiB/s&lt;/strong&gt; and &lt;strong&gt;14.4
MiB/s&lt;/strong&gt; for encryption (write) and decryption (read).&lt;/p&gt;

&lt;h2 id=&#34;fat32-write-speed-dd&#34;&gt;FAT32 write speed (dd)&lt;/h2&gt;

&lt;p&gt;For a baseline comparison, I test the write speed of an unencrypted FAT32 file
system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lizard:/mnt/slowpoke# time dd bs=1M count=4096 if=/dev/zero of=test conv=fsync
4096+0 records in
4095+1 records out
real    11m 28.47s
user    0m 0.08s
sys     0m 45.25s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The measurement of write speed is &lt;strong&gt;5.95 MB/s&lt;/strong&gt;.  That&amp;rsquo;s much lower than what I
was expecting.  I achieve write speeds of 40 MB/s from my laptop on the same
external disk.&lt;/p&gt;

&lt;h2 id=&#34;luks-ext4-write-speed-dd&#34;&gt;LUKS + ext4 write speed (dd)&lt;/h2&gt;

&lt;p&gt;This test should theoretically give upper bound results for my setup.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lizard:/mnt/wd_ext# time dd bs=1M count=4096 if=/dev/zero of=test conv=fsync
4096+0 records in
4096+0 records out
real    21m 23.27s
user    0m 0.07s
sys     0m 36.35s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s just &lt;strong&gt;3.19 MB/s&lt;/strong&gt;, which is extremely slow.&lt;/p&gt;

&lt;h2 id=&#34;luks-ext4-rsync&#34;&gt;LUKS + ext4 (rsync)&lt;/h2&gt;

&lt;p&gt;This test measures exactly one of my use cases, as I plan to use rsync for my
backups.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % rsync -v --progress movie.mp4 green-local:/mnt/disk/
movie.mp4
  1,991,346,871 100%    9.17MB/s    0:03:27 (xfr#1, to-chk=0/1)

sent 1,991,833,155 bytes  received 35 bytes  9,553,156.79 bytes/sec
total size is 1,991,346,871  speedup is 1.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Surprisingly this one gives much better results than the &lt;code&gt;dd&lt;/code&gt; tests: &lt;strong&gt;9.11
MB/s&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;First of all, I don&amp;rsquo;t understand why the &lt;code&gt;dd&lt;/code&gt; tests performed so badly.  The
&lt;code&gt;fsync&lt;/code&gt; option should make sure that data is written to disk and not cached:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        conv=fsync      Physically write data out before finishing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maybe there&amp;rsquo;s a bug in busybox&amp;rsquo;s dd?  Or am I missing something?  I was
expecting to find the same speeds as LUKS encryption speeds here.&lt;/p&gt;

&lt;p&gt;The rsync test gives us the best performance we could expect, considering that
the limit comes from the 100 Mbit Ethernet, we won&amp;rsquo;t be able to transfer data at
higher speeds than ~10 MB/s.  In this case, the usage of disk encryption isn&amp;rsquo;t
making things slower.&lt;/p&gt;

&lt;p&gt;So overall I&amp;rsquo;m expecting to get transfer speeds (including writing to the
encrypted partition) of about &lt;strong&gt;9-10 MB/s&lt;/strong&gt;.  I&amp;rsquo;m happy with this and I believe
it should suit my needs, as I plan do backups every day in my local network.&lt;/p&gt;

&lt;p&gt;In the next post I will explain how to set up a git server with a web interface.
Stay tunned!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>