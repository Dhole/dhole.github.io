<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
	<meta name="generator" content="Hugo 0.48" />
        
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <title>Dhole&#39;s blog &middot; Dhole&#39;s blog</title>
        
        
        <link rel="stylesheet" href="https://lizard.kyasuka.com/blog//css/liquorice.css" />
        <link rel="shortcut icon" href="/favicon.ico" />
        <link rel="alternate" href="https://lizard.kyasuka.com/blog/index.xml" type="application/rss+xml" title="Dhole&#39;s blog" />
    </head>
    <body class="li-body">

<header class="li-page-header">
    <div class="container">
        <div class="row">
            <div class="sixteen columns"></div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                <a href="https://lizard.kyasuka.com/blog/">Dhole&#39;s blog</a></div>
                <div class="li-menu li-right">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="/blog/post"> articles </a></li>
                        
                            <li><a href="/blog/categories"> categories </a></li>
                        
                            <li><a href="/blog/about"> about </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="/blog/post"> articles </a></li>
                    
                        <li><a href="/blog/categories"> categories </a></li>
                    
                        <li><a href="/blog/about"> about </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>


    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-main-article-list">
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/pulseaudio_multiple_users/">Pulseaudio for multi-user Linux </a></h2>
        <time class="li-article-date">Monday, August 27, 2018</time>
    </header>
    <section class="li-article-section">
        My setup For some time I&rsquo;ve been using several unix users for my daily work in my desktop computer. After trying out Qubes OS for some time (an OS that achieves security by compartmentalization: different kinds of activites are performed in a different VM, isolating the data of each activity from each other), I came back to GNU/Linux and realized that there&rsquo;s already a security separation in Unix (albeit not as secure as virtualization as in Qubes): users.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/pulseaudio_multiple_users/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/gameboy_cartridge_rw_1/">Programming Game Boy Chinese cartridges with an STM32F4 </a></h2>
        <time class="li-article-date">Monday, March 12, 2018</time>
    </header>
    <section class="li-article-section">
        Introduction For the past few years I have been interested in the Game Boy: I&rsquo;ve written an emulator in C (without sound), I developed a physical cartridge &ldquo;emulator&rdquo; using a microcontroller, and most recently I&rsquo;ve built a project to interface my PC with the Game Link. I&rsquo;ve also played a bit with Game Boy programming.
In the past I considered buying a Game Boy flashcart so that I could run demos and other scene ROMs on real hardware comfortably, but the price of such carts is a bit high.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/gameboy_cartridge_rw_1/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/gameboy_serial_3/">Printing on the Game Boy Printer using an STM32F4 </a></h2>
        <time class="li-article-date">Sunday, February 25, 2018</time>
    </header>
    <section class="li-article-section">
        In this third and final part of the project about the Game Boy serial communication I will explain how I managed to print on the Game Boy Printer from my PC using an STM32F4 as the bridge between the two. The encoding of the image into Game Boy tiles will happen on the PC, which will send it to the STM32F4 following the packet format of the Game Boy Printer.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/gameboy_serial_3/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/gameboy_serial_2/">Virtual Game Boy Printer with an STM32F4 </a></h2>
        <time class="li-article-date">Friday, February 23, 2018</time>
    </header>
    <section class="li-article-section">
        In this second part of the project about interfacing the Game Boy serial communication with an embedded development board I will explain how I built a Virtual Game Boy Printer. The embedded board will be simulating a real Game Boy Printer, replying to the Game Boy following the protocol used by the Game Boy Printer so that the Game Boy sends the entire data meant to be print. This data will then be forwarded to my computer which will construct a PNG image out of it.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/gameboy_serial_2/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/gameboy_serial_1/">Sniffing Game Boy serial traffic with an STM32F4 </a></h2>
        <time class="li-article-date">Wednesday, February 14, 2018</time>
    </header>
    <section class="li-article-section">
        In these series of blog posts I will write about the Game Boy serial communication protocol and how to interact with it by using an embedded development board. The code for the development board will be written in C, and the code running on the computer will be written in Rust.
The first part will consist on understanding the Game Boy serial communication protocol, becoming familiar with embedded development using the libopencm3 free/libre library and finally building a serial communication sniffer to capture the transmission of data on the Game Link Cable.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/gameboy_serial_1/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/luks_on_chip/">Enabling LUKS on the PocketCHIP </a></h2>
        <time class="li-article-date">Thursday, November 23, 2017</time>
    </header>
    <section class="li-article-section">
        Introduction I&rsquo;ve recently acquired a handheld ARM computer with screen and keyboard called the PocketCHIP. The main board on the device is called the CHIP, which is a tiny ARM computer capable of running Linux that is sold for $9.
After flashing it with the CHIP 4.4 GUI OS, a flavor of Debian released by Next Thing Co (the company that made the PocketCHIP) I noticed I wasn&rsquo;t able to mount LUKS-encrypted partitions due to missing kernel modules.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/luks_on_chip/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/raspberry_pi_alpine_upgrade/">Alpine Linux: Upgrading on Raspberry Pi </a></h2>
        <time class="li-article-date">Monday, June 26, 2017</time>
    </header>
    <section class="li-article-section">
        This post describes the upgrade procedure I follow to upgrade my Raspberry Pi Alpine Linux installation. Alpine Linux on the Raspberry Pi runs from ramfs and thus the upgrading is not straightforward. Most of the details are taken from the Alpine Linux Wiki. I&rsquo;m not sure if Alpine Linux does any verification on the new downloaded release, so I&rsquo;m doing that manually on another computer.
Upgrading First of all, replace the repository confiration to point to the new version:
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/raspberry_pi_alpine_upgrade/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/rdiff-backup-alpine/">rdiff-backup-1.2.8 in Alpine </a></h2>
        <time class="li-article-date">Tuesday, November 1, 2016</time>
    </header>
    <section class="li-article-section">
        Introduction A few days ago I wanted to start doing incremental backups from my laptop to my Raspberry Pi 2 running Alpine Linux. I&rsquo;ve had used rdiff-backup for some years now and I&rsquo;m really happy with it. rdiff-backup is similar to rsync, in the sense that lets you synchronize folders over the network, but it has two added nice features: when synchronizing, only the differences between the files that have changed are sent; and after every synchronization, the differences between the old version of the files and the new ones is kept.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/rdiff-backup-alpine/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/raspberry_pi_git/">Raspberry Pi: git server (cgit with lighttpd) </a></h2>
        <time class="li-article-date">Friday, October 21, 2016</time>
    </header>
    <section class="li-article-section">
        Introduction In this post I will explain what&rsquo;s required to set up a git server. We&rsquo;ll use cgit to provide a web interface and also allow cloning/pulling through HTTP. ssh will also be available for cloning/pulling and pushing.
We&rsquo;ll setup two groups of repositories: a public and a private one.
Cgit First of all, we&rsquo;ll create a git user and move it&rsquo;s home to the encrypted partition. For convenience we&rsquo;ll also link that home directory to /git.
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/raspberry_pi_git/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                        
                            <div class="li-article">
                                <article>
    <header>
        <h2><a href="https://lizard.kyasuka.com/blog/post/raspberry_pi_alpine_lighttpd/">Raspberry Pi: setting up alpine, lighttpd and letsencrypt </a></h2>
        <time class="li-article-date">Friday, October 21, 2016</time>
    </header>
    <section class="li-article-section">
        Introduction In this post I will explain how to set up Alpine Linux for the RPi, with the necessary configuration for the RPi to power a USB hard drive, how to install lighttpd and configure automatic renewal of TLS certificates with lestencrypt.
Alpine Linux Alpine Linux can be installed on te RPi following the wiki guide.
After instalation, we add a new user which we will use for logging in:
    </section>
    <footer>
        <a href='https://lizard.kyasuka.com/blog/post/raspberry_pi_alpine_lighttpd/'>More</a>
    </footer>
</article>

                            </div>
                        
                    
                </div>
            </div>
            <h2 style="text-align: center">
                
                    
                    <a href="/blog/post">
                        See all articles
                    </a>
                    
                
                    
                
                    
                
            </h2>
        </div>
    </div>

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-page-footer-legal">
                    &copy; 2018. All rights reserved. 
                </div>
                <div class="li-page-footer-theme">
                    <span class="">Theme based on <a href="http://github.com/eliasson/liquorice/">liquorice</a> for <a href="http://hugo.spf13.com">hugo</a></span>
                </div>
            </div>
        </div>
    </div>
</footer>

    <script type="text/javascript">
    <!--
    function toggle(id) {
        var e = document.getElementById(id);
        e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
    }
    
    </script>
    
    </body>
</html>

